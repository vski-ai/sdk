// Generated by dts-bundle-generator v9.5.1

export interface SubscriptionOptions {
	lastId?: string;
	group?: string;
}
export interface RealtimeEvent {
	action: "create" | "update" | "delete";
	record: any;
}
export interface WorkflowContext {
	runId: string;
	workflowName: string;
	history: Map<string, any>;
	stepAttempts: Map<string, number>;
	sleep(duration: number | string): Promise<void>;
	waitForSignal<T = any>(name: string): Promise<T>;
	parallel<T>(steps: (() => Promise<T>)[]): Promise<T[]>;
}
export declare class RocketBaseClient {
	baseUrl: string;
	private token;
	private apiKey;
	dbName: string;
	private adminDbName;
	private realtimeSocket;
	private subscriptions;
	constructor(baseUrl?: string);
	getToken(): string;
	setToken(token: string | null): void;
	setApiKey(key: string | null): void;
	setDb(db: string): void;
	setAdminDb(db: string): void;
	close(): void;
	private get headers();
	private get adminHeaders();
	get settings(): {
		databases: {
			list: () => Promise<any>;
			create: (data: {
				name: string;
				extensions?: string[];
				initScript?: string;
			}) => Promise<any>;
			delete: (name: string) => Promise<boolean>;
		};
		collections: {
			create: (data: any) => Promise<any>;
			update: (id: string, data: any) => Promise<any>;
			delete: (id: string) => Promise<boolean>;
			getList: () => Promise<any>;
		};
	};
	get auth(): {
		login: (email: string, pass: string) => Promise<any>;
		register: (data: any) => Promise<any>;
		me: () => Promise<any>;
		listMethods: () => Promise<any>;
		authViaOAuth2: (provider: string, code: string, redirectUrl: string) => Promise<any>;
	};
	get keys(): {
		generate: (data: any) => Promise<any>;
	};
	get admins(): {
		authWithPassword: (identity: string, password: string) => Promise<any>;
		init: (data: any) => Promise<any>;
		hasAdmins: () => Promise<any>;
		me: () => Promise<any>;
	};
	get cron(): {
		list: () => Promise<any>;
		create: (data: any) => Promise<any>;
		delete: (name: string) => Promise<boolean>;
	};
	get webhookLogs(): {
		list: (filters?: {
			collection?: string;
			status?: string;
			page?: number;
			perPage?: number;
		}) => Promise<any>;
	};
	get workflowStats(): {
		get: () => Promise<any>;
	};
	collection(name: string): {
		getList: (page?: number, perPage?: number, options?: {
			filter?: string;
			expand?: string;
		}) => Promise<any>;
		getOne: (id: string, options?: {
			expand?: string;
		}) => Promise<any>;
		search: (q: string, options?: {
			page?: number;
			perPage?: number;
			expand?: string;
			snippet?: boolean;
		}) => Promise<any>;
		getView: (slug: string, options?: {
			page?: number;
			perPage?: number;
			expand?: string;
			filter?: string;
			sort?: string;
		}) => Promise<any>;
		create: (data: any) => Promise<any>;
		update: (id: string, data: any) => Promise<any>;
		bulkUpdate: (ids: string[], data: any) => Promise<any>;
		delete: (id: string) => Promise<boolean>;
		bulkDelete: (ids: string[]) => Promise<any>;
		authWithPassword: (identity: string, password: string) => Promise<any>;
		subscribe: (callback: (e: RealtimeEvent) => void, options?: SubscriptionOptions) => () => void;
	};
	private connectRealtime;
	get migrations(): {
		getList: (page?: number, perPage?: number, options?: {
			filter?: string;
			sort?: string;
		}) => Promise<any>;
		create: (data: {
			name: string;
			appliedAt: string;
			batch?: number;
		}) => Promise<any>;
		delete: (id: string) => Promise<boolean>;
		run: (migrations: {
			name: string;
			up: (sdk: RocketBaseClient) => Promise<void>;
		}[]) => Promise<void>;
	};
	get workflow(): {
		createRun: (data: any) => Promise<any>;
		trigger: (workflowName: string, input: any[], options?: any) => Promise<any>;
		resume: (runId: string) => Promise<any>;
		getRun: (runId: string) => Promise<any>;
		updateRun: (runId: string, data: any) => Promise<any>;
		listRuns: (params?: {
			workflowName?: string;
			status?: string;
			limit?: number;
			cursor?: string;
		}) => Promise<any>;
		createStep: (runId: string, data: any) => Promise<any>;
		updateStep: (runId: string, stepId: string, data: any) => Promise<any>;
		createEvent: (runId: string, data: any) => Promise<any>;
		listEvents: (runId: string) => Promise<any>;
		pollQueue: (queueName: string) => Promise<any>;
		sendSignal: (runId: string, signalName: string, data: any, correlationId?: string) => Promise<boolean>;
		queueMessage: (queueName: string, message: any, opts?: any) => Promise<any>;
		ack: (messageId: string) => Promise<any>;
		nack: (messageId: string) => Promise<any>;
		hooks: {
			create: (runId: string, data: any) => Promise<any>;
			get: (id: string) => Promise<any>;
			getByToken: (token: string) => Promise<any>;
			list: (runId: string) => Promise<any>;
			dispose: (id: string) => Promise<any>;
		};
	};
	gate(name: string, data?: any, options?: RequestInit): Promise<Response>;
}
export declare const WorkflowRegistry: Map<string, any>;
export declare class WorkflowBase {
	client: RocketBaseClient;
	runId: string;
	workflowName: string;
	history: Map<string, any>;
	completedSteps: Set<string>;
	rollbackStack: string[];
	stepAttempts: Map<string, number>;
	callCounter: number;
	signalQueues: Map<string, any[]>;
	signalCursors: Map<string, number>;
	isSuspended: boolean;
	constructor(client?: RocketBaseClient);
	parallel<T>(steps: (() => Promise<T>)[]): Promise<T[]>;
	getDeterministicId(prefix: string): string;
	sleep(duration: number | string): Promise<void>;
	waitForSignal<T = any>(name: string): Promise<T>;
	runRollback(error: any): Promise<void>;
	rebuildState(events: any[]): void;
	executeStep(id: string, fn: (...args: any[]) => Promise<any>, args: any[], options?: {
		retries?: number;
		rollback?: string[];
		timeout?: string;
	}): Promise<any>;
}
export declare function Workflow(name: string): (constructor: Function) => void;
export declare function Step(id: string, options?: {
	retries?: number;
	rollback?: string[];
	timeout?: string;
}): (_target: any, _propertyKey: string, descriptor: PropertyDescriptor) => void;
export declare class WorkflowWorker {
	private client;
	private socket;
	private active;
	private workflowName;
	private stopCallback;
	constructor(client: RocketBaseClient);
	start(workflowName: string, options?: {
		concurrency?: number;
		resume?: boolean;
	}): Promise<void>;
	private resumePending;
	stop(): void;
	private connect;
	processJob(job: any): Promise<void>;
}
export declare class StopRollback extends Error {
	constructor(message?: string);
}
export declare function workflow(name: string): {
	run: (fn: (ctx: WorkflowContext, ...args: any[]) => Promise<any>) => {
		new (client?: RocketBaseClient): {
			workflowName: string;
			run(...args: any[]): Promise<any>;
			client: RocketBaseClient;
			runId: string;
			history: Map<string, any>;
			completedSteps: Set<string>;
			rollbackStack: string[];
			stepAttempts: Map<string, number>;
			callCounter: number;
			signalQueues: Map<string, any[]>;
			signalCursors: Map<string, number>;
			isSuspended: boolean;
			parallel<T>(steps: (() => Promise<T>)[]): Promise<T[]>;
			getDeterministicId(prefix: string): string;
			sleep(duration: number | string): Promise<void>;
			waitForSignal<T = any>(name: string): Promise<T>;
			runRollback(error: any): Promise<void>;
			rebuildState(events: any[]): void;
			executeStep(id: string, fn: (...args: any[]) => Promise<any>, args: any[], options?: {
				retries?: number;
				rollback?: string[];
				timeout?: string;
			}): Promise<any>;
		};
		workflowName: string;
	};
};
export declare function step(idOrFn: string | ((...args: any[]) => Promise<any>), fnOrOptions?: ((...args: any[]) => Promise<any>) | {
	retries?: number;
	rollback?: string[];
	timeout?: string;
}, options?: {
	retries?: number;
	rollback?: string[];
	timeout?: string;
}): (this: WorkflowContext | void, ...args: any[]) => Promise<any>;

export {};
