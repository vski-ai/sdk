// Generated by dts-bundle-generator v9.5.1

/**
 * Options for realtime subscriptions.
 */
export interface SubscriptionOptions {
  /**
   * The ID of the last event received. Used for resuming subscriptions from a specific point.
   */
  lastId?: string;
  /**
   * The consumer group for the subscription.
   * If specified, events will be distributed among subscribers in the same group.
   */
  group?: string;
}
/**
 * Represents a realtime event from the database.
 */
export interface RealtimeEvent<T = RecordData> {
  /**
   * The type of action that triggered the event.
   */
  action: "create" | "update" | "delete";
  /**
   * The record associated with the event.
   */
  record: T;
}
/**
 * Interface representing the context available within a workflow execution.
 */
export interface WorkflowContext {
  /**
   * The unique identifier for the current workflow run.
   */
  runId: string;
  /**
   * The name of the workflow.
   */
  workflowName: string;
  /**
   * The execution history of the workflow, mapping step IDs to their results.
   */
  history: Map<string, unknown>;
  /**
   * Tracks the number of attempts for each step.
   */
  stepAttempts: Map<string, number>;
  /**
   * Pauses execution for a specified duration.
   * @param duration - The duration to sleep in milliseconds or as a string (e.g., "1s", "5m").
   * @returns A promise that resolves when the sleep is completed.
   */
  sleep(duration: number | string): Promise<void>;
  /**
   * Pauses execution until a specific signal is received.
   * @param name - The name of the signal to wait for.
   * @returns The data payload associated with the signal.
   */
  waitForSignal<T = unknown>(name: string): Promise<T>;
  /**
   * Executes multiple steps in parallel.
   * @param steps - An array of functions returning promises to be executed concurrently.
   * @returns An array of results from the executed steps.
   */
  parallel<T>(steps: (() => Promise<T>)[]): Promise<T[]>;
}
/**
 * Generic type for record data.
 */
export type RecordData = Record<"id", string> & Record<string, unknown>;
/**
 * Represents a paginated list of items.
 */
export interface PaginatedList<T> {
  /** The current page number. */
  page: number;
  /** The number of items per page. */
  perPage: number;
  /** The total number of items available. */
  totalItems: number;
  /** The total number of pages available. */
  totalPages: number;
  /** The items on the current page. */
  items: T[];
}
/**
 * Configuration for creating or connecting to a database.
 */
export interface DatabaseConfig {
  /** The name of the database. */
  name: string;
  /** Optional list of PostgreSQL extensions to enable. */
  extensions?: string[];
  /** Optional SQL script to run when the database is created. */
  initScript?: string;
}
/**
 * Configuration for a single field in a collection.
 */
export interface FieldConfig {
  /** Unique ID of the field. */
  id: string;
  /** Name of the field in the database. */
  name: string;
  /** Type of the field. */
  type:
    | "text"
    | "number"
    | "bool"
    | "email"
    | "url"
    | "date"
    | "select"
    | "json"
    | "file"
    | "relation"
    | "user";
  /** Whether the field is required. */
  required?: boolean;
  /** Whether the field must be unique across all records. */
  unique?: boolean;
  /** Whether the field should be hidden in API responses. */
  hidden?: boolean;
  /** Whether the field is system-managed. */
  system?: boolean;
  /** For relation or file fields, the maximum number of items. */
  maxSelect?: number;
  /** For relation fields, the name of the target collection. */
  toCollection?: string;
  /** Additional field-specific options. */
  options?: Record<string, unknown>;
  /** Default value for the field. */
  default?: unknown;
  /** Catch-all for additional properties. */
  [key: string]: unknown;
}
/**
 * Configuration for a database trigger (webhook).
 */
export interface TriggerConfig {
  /** Unique ID of the trigger. */
  id: string;
  /** Whether the trigger is enabled. */
  enabled: boolean;
  /** The action that triggers the webhook. */
  action: "create" | "update" | "delete" | "INSERT" | "UPDATE" | "DELETE";
  /** The URL to send the webhook request to. */
  url: string;
}
/**
 * Configuration for a full-text search index.
 */
export interface FtsIndexConfig {
  /** Unique ID of the index. */
  id: string;
  /** The fields to include in the index. */
  fields: string[];
}
/**
 * Configuration for a database view.
 */
export interface ViewConfig {
  /** Unique slug for the view. */
  slug: string;
  /** The SQL query defining the view. */
  sql: string;
}
export interface RetentionConfig {
  enabled: boolean;
  days: number;
  query: string;
}
/**
 * Configuration for a collection.
 */
export interface CollectionConfig {
  /** Unique ID of the collection. */
  id: string;
  /** Unique name of the collection. */
  name: string;
  /** Type of the collection. */
  type?: "base" | "auth" | "view" | "timescale";
  /** Whether the collection is system-managed. */
  system?: boolean;
  /** Whether realtime events are enabled for this collection. */
  realtime?: boolean;
  /** Rules for different operations. */
  listRule?: string | null;
  /** Rules for viewing a single record. */
  viewRule?: string | null;
  /** Rules for creating a record. */
  createRule?: string | null;
  /** Rules for updating a record. */
  updateRule?: string | null;
  /** Rules for deleting a record. */
  deleteRule?: string | null;
  /** Fields defined in the collection. */
  fields: FieldConfig[];
  /** Triggers (webhooks) for the collection. */
  triggers?: TriggerConfig[];
  /** Standard database indexes. */
  indexes?: string[];
  /** Full-text search indexes. */
  ftsIndexes?: FtsIndexConfig[];
  /** Database views. */
  views?: ViewConfig[];
  /** Field-level access rules. */
  fieldRules?: Record<string, string[]>;
  /** Tags for organizing collections. */
  tags?: string | null;
  /** Additional collection-specific options. */
  options?: Record<string, unknown>;
  retention?: RetentionConfig;
}
/**
 * Details about available authentication methods.
 */
export interface AuthMethods {
  /** Whether email/password authentication is enabled. */
  emailPassword: boolean;
  /** Configuration for OAuth2 providers. */
  oauth2: {
    /** List of available providers. */
    providers: {
      /** Name of the provider. */
      name: string;
      /** URL for the authorization endpoint. */
      authUrl: string;
    }[];
  };
}
/**
 * Response from an authentication request.
 */
export interface AuthResponse {
  /** JWT token. */
  token: string;
  /** Authenticated user data. */
  user: RecordData;
}
/**
 * Represents a registered cron job.
 */
export interface CronJob {
  /** Unique ID of the cron job. */
  id: number;
  /** Name of the cron job. */
  name: string;
  /** Cron schedule expression. */
  schedule: string;
  /** SQL command or HTTP request to execute. */
  command: string;
  /** Database context for the job. */
  database: string;
  /** Whether the job is active. */
  active: boolean;
}
/**
 * Configuration for creating a new cron job.
 */
export interface CronJobConfig {
  /** Name of the cron job. */
  name: string;
  /** Cron schedule expression. */
  schedule: string;
  /** Type of task to perform. */
  type: "sql" | "http";
  /** SQL script for 'sql' type tasks. */
  sql?: string;
  /** URL for 'http' type tasks. */
  url?: string;
  /** HTTP method for 'http' type tasks. */
  method?: "GET" | "POST" | "PUT" | "DELETE";
  /** Request body for 'http' type tasks. */
  body?: string;
  /** Content type for 'http' type tasks. */
  contentType?: "json" | "urlencoded";
}
/**
 * Represents a log entry for a webhook execution.
 */
export interface WebhookLog {
  /** Unique ID of the log entry. */
  id: string;
  /** URL that was called. */
  url: string;
  /** Data that was sent. */
  payload: {
    /** Target database. */
    database: string;
    /** Target collection. */
    collection: string;
    /** ID of the triggering record. */
    id: string;
    /** Action that triggered the webhook. */
    action: string;
    /** When the event occurred. */
    timestamp: string;
  };
  /** Execution status. */
  status: "pending" | "processing" | "success" | "failed";
  /** HTTP response status code. */
  http_status: number | null;
  /** Error message if execution failed. */
  error_msg: string | null;
  /** Response body from the target URL. */
  response_body: string | null;
  /** Number of times the webhook has been tried. */
  tries: number;
  /** Creation timestamp. */
  created_at: string;
  /** Last update timestamp. */
  updated_at: string;
}
/**
 * Represents a workflow run.
 */
export interface WorkflowRun {
  /** Unique identifier for the run. */
  runId: string;
  /** Identifier of the deployment that executed the run. */
  deploymentId: string;
  /** Name of the executed workflow. */
  workflowName: string;
  /** Current execution status. */
  status: "pending" | "running" | "completed" | "failed" | "cancelled";
  /** Arguments passed to the workflow. */
  input: unknown[];
  /** Final output of the workflow. */
  output: unknown;
  /** Error details if the run failed. */
  error: {
    /** Error message. */
    message: string;
    /** Optional stack trace. */
    stack?: string;
  } | null;
  /** Context data used during execution. */
  executionContext: RecordData;
  /** Current count of events generated by the run. */
  eventCount: number;
  /** Maximum allowed number of events for the run. */
  maxEvents: number;
  /** Execution timeout in milliseconds. */
  executionTimeout: number;
  /** When the run started execution. */
  startedAt: string | null;
  /** When the run completed execution. */
  completedAt: string | null;
  /** When the run record was created. */
  createdAt: string;
  /** When the run record was last updated. */
  updatedAt: string;
}
/**
 * Aggregated statistics for workflows.
 */
export interface WorkflowStats {
  /** Total number of workflow runs. */
  total: number;
  /** Number of currently active runs. */
  active: number;
  /** Number of successfully completed runs. */
  completed: number;
  /** Number of failed runs. */
  failed: number;
}
/**
 * Represents a database migration record.
 */
export interface Migration {
  /** Unique ID of the migration. */
  id: string;
  /** Name of the migration. */
  name: string;
  /** When the migration was applied. */
  appliedAt: string;
  /** Batch number for grouping migrations. */
  batch: number;
}
/**
 * Represents an event within a workflow run.
 */
export interface WorkflowEvent {
  /** Unique ID of the event. */
  eventId: string;
  /** ID of the workflow run this event belongs to. */
  runId: string;
  /** Optional ID of the step that generated the event. */
  stepId?: string | null;
  /** Type identifier for the event. */
  eventType: string;
  /** Correlation identifier for matching events. */
  correlationId?: string | null;
  /** Data payload for the event. */
  payload: Record<string, unknown>;
  /** When the event occurred. */
  createdAt: string;
}
/**
 * Represents a job assignment for a workflow worker.
 */
export interface WorkflowJob {
  /** Unique ID of the job message. */
  id: string;
  /** Job data payload. */
  data: {
    /** ID of the run to process. */
    runId: string;
    /** Name of the workflow. */
    workflowName: string;
    /** Input arguments for the workflow run. */
    input?: unknown[];
  };
}
/**
 * Options for starting a workflow.
 */
export interface WorkflowOptions {
  /** Maximum number of events allowed for the run. */
  maxEvents?: number;
  /** Maximum time allowed for execution in milliseconds. */
  executionTimeout?: number;
  /** Deployment identifier. */
  deploymentId?: string;
}
/**
 * Options for a single workflow step.
 */
export interface StepOptions {
  /** Number of retry attempts if step fails. */
  retries?: number;
  /** List of method names to call for rollback if workflow fails (decorator style). */
  rollback?: string[];
  /** Rollback function to call directly if step fails (functional style). */
  rollbackFn?: (error: unknown, accumulator: any) => Promise<any> | any;
  /** Timeout for step (not currently implemented in worker). */
  timeout?: string;
}
/**
 * Main client for interacting with the RocketBase backend.
 * Provides access to databases, collections, authentication, workflows, and realtime features.
 */
export declare class RocketBaseClient {
  /** The base URL of the RocketBase server. */
  baseUrl: string;
  private token;
  private apiKey;
  /** The name of the database to use. */
  dbName: string;
  private adminDbName;
  private realtimeSocket;
  private workflowSocket;
  private subscriptions;
  private workflowSubscriptions;
  /**
   * Creates a new instance of the RocketBase client.
   * @param baseUrl - The base URL of the RocketBase server (default: http://127.0.0.1:3000).
   */
  constructor(baseUrl?: string);
  /**
   * Retrieves the current authentication token.
   * @returns The JWT token or null if not set.
   */
  getToken(): string | null;
  /**
   * Sets the authentication token.
   * Updates the local storage and manages the realtime connection.
   * @param token - The new JWT token or null to clear it.
   */
  setToken(token: string | null): void;
  /**
   * Sets the API key for backend-to-backend communication.
   * @param key - The API key or null to clear it.
   */
  setApiKey(key: string | null): void;
  /**
   * Sets the target database for subsequent requests.
   * @param db - The name of the database.
   */
  setDb(db: string): void;
  /**
   * Sets the target admin database for administrative requests.
   * @param db - The name of the admin database (default: postgres).
   */
  setAdminDb(db: string): void;
  /**
   * Closes the client and terminates any active realtime connections.
   */
  close(): void;
  /**
   * Subscribes a worker to jobs for a specific workflow.
   * @param workflowName - The name of the workflow.
   * @param callback - Function called when a job is received.
   * @returns A function to unsubscribe.
   */
  subscribeWorkflow(
    workflowName: string,
    callback: (job: any) => void,
  ): () => void;
  /** Connects to the workflow WebSocket server. */
  private connectWorkflow;
  /** Headers for standard requests. */
  private get headers();
  /** Headers for administrative requests. */
  private get adminHeaders();
  /**
   * Namespace for system settings and configuration (Databases, Collections).
   * @returns An object with database and collection management methods.
   */
  get settings(): {
    databases: {
      list: () => Promise<string[]>;
      create: (data: DatabaseConfig) => Promise<unknown>;
      delete: (name: string) => Promise<boolean>;
    };
    collections: {
      create: (data: CollectionConfig) => Promise<unknown>;
      update: (id: string, data: Partial<CollectionConfig>) => Promise<unknown>;
      delete: (id: string) => Promise<boolean>;
      getList: () => Promise<PaginatedList<CollectionConfig>>;
    };
  };
  /**
   * Namespace for authentication operations (Login, Register, OAuth).
   * @returns An object with authentication methods.
   */
  get auth(): {
    login: (email: string, pass: string) => Promise<AuthResponse>;
    register: (data: RecordData) => Promise<unknown>;
    me: () => Promise<RecordData>;
    listMethods: () => Promise<AuthMethods>;
    authViaOAuth2: (
      provider: string,
      code: string,
      redirectUrl: string,
    ) => Promise<AuthResponse>;
  };
  /**
   * Namespace for API key management.
   * @returns An object with API key management methods.
   */
  get keys(): {
    generate: (data: {
      name?: string;
      enabled?: boolean;
    }) => Promise<unknown>;
  };
  /**
   * Namespace for admin-level operations.
   * @returns An object with administrative methods.
   */
  get admins(): {
    authWithPassword: (
      identity: string,
      password: string,
    ) => Promise<AuthResponse>;
    init: (data: {
      email: string;
      password: string;
    }) => Promise<unknown>;
    hasAdmins: () => Promise<{
      hasAdmins: boolean;
    }>;
    me: () => Promise<RecordData>;
  };
  /**
   * Namespace for Cron job management.
   * @returns An object with cron job management methods.
   */
  get cron(): {
    list: () => Promise<CronJob[]>;
    create: (data: CronJobConfig) => Promise<unknown>;
    delete: (name: string) => Promise<boolean>;
  };
  /**
   * Namespace for Webhook logs.
   * @returns An object with webhook log access methods.
   */
  get webhookLogs(): {
    list: (filters?: {
      collection?: string;
      status?: string;
      page?: number;
      perPage?: number;
    }) => Promise<PaginatedList<WebhookLog>>;
  };
  /**
   * Namespace for Workflow statistics.
   * @returns An object with workflow statistics methods.
   */
  get workflowStats(): {
    get: () => Promise<WorkflowStats>;
  };
  /**
   * Returns a handler for a specific collection.
   * Provides methods for record CRUD, search, and realtime subscriptions.
   * @param name - The name of the collection.
   * @returns A collection handler object.
   */
  collection<T = RecordData>(name: string): {
    getList: (page?: number, perPage?: number, options?: {
      filter?: string;
      expand?: string;
      sort?: string;
    }) => Promise<PaginatedList<T>>;
    getOne: (id: string, options?: {
      expand?: string;
    }) => Promise<T>;
    search: (q: string, options?: {
      page?: number;
      perPage?: number;
      expand?: string;
      snippet?: boolean;
    }) => Promise<PaginatedList<T>>;
    getView: (slug: string, options?: {
      page?: number;
      perPage?: number;
      expand?: string;
      filter?: string;
      sort?: string;
    }) => Promise<PaginatedList<T>>;
    create: (data: RecordData | FormData | Partial<T>) => Promise<T>;
    update: (
      id: string,
      data: RecordData | FormData | Partial<T>,
    ) => Promise<T>;
    bulkUpdate: (ids: string[], data: RecordData | Partial<T>) => Promise<{
      updated: string[];
    }>;
    delete: (id: string) => Promise<boolean>;
    bulkDelete: (ids: string[]) => Promise<{
      deleted: string[];
    }>;
    authWithPassword: (
      identity: string,
      password: string,
    ) => Promise<AuthResponse>;
    subscribe: (
      callback: (e: RealtimeEvent<T>) => void,
      options?: SubscriptionOptions,
    ) => () => void;
  };
  /** Connects to the realtime WebSocket server. */
  private connectRealtime;
  /**
   * Namespace for database migrations.
   * @returns An object with migration methods.
   */
  get migrations(): {
    getList: (page?: number, perPage?: number, options?: {
      filter?: string;
      sort?: string;
    }) => Promise<PaginatedList<Migration>>;
    create: (data: {
      name: string;
      appliedAt: string;
      batch?: number;
    }) => Promise<Migration>;
    delete: (id: string) => Promise<boolean>;
    run: (migrations: {
      name: string;
      up: (sdk: RocketBaseClient) => Promise<void>;
    }[]) => Promise<void>;
  };
  /**
   * Namespace for Workflow operations (Runs, Events, Signals, Queues).
   * @returns An object with workflow management methods.
   */
  get workflow(): {
    createRun: (data: Partial<WorkflowRun>) => Promise<WorkflowRun>;
    trigger: (
      workflowName: string,
      input: unknown[],
      options?: any,
    ) => Promise<WorkflowRun>;
    resume: (runId: string) => Promise<WorkflowRun>;
    getRun: (runId: string) => Promise<WorkflowRun>;
    updateRun: (
      runId: string,
      data: Partial<WorkflowRun>,
    ) => Promise<WorkflowRun>;
    cancelRun: (runId: string, reason?: string) => Promise<unknown>;
    listRuns: (params?: {
      workflowName?: string;
      status?: string;
      limit?: number;
      cursor?: string;
    }) => Promise<PaginatedList<WorkflowRun>>;
    createStep: (runId: string, data: any) => Promise<unknown>;
    updateStep: (runId: string, stepId: string, data: any) => Promise<unknown>;
    createEvent: (runId: string, data: {
      eventType: string;
      correlationId?: string;
      payload: Record<string, unknown>;
    }) => Promise<WorkflowEvent>;
    listEvents: (runId: string) => Promise<WorkflowEvent[]>;
    pollQueue: (queueName: string) => Promise<unknown>;
    sendSignal: (
      runId: string,
      signalName: string,
      data: any,
      correlationId?: string,
    ) => Promise<boolean>;
    queueMessage: (
      queueName: string,
      message: any,
      opts?: any,
    ) => Promise<unknown>;
    getJob: (messageId: string) => Promise<unknown>;
    getProcessingJobs: (runId: string) => Promise<unknown>;
    ack: (messageId: string) => Promise<unknown>;
    nack: (messageId: string) => Promise<unknown>;
    touch: (messageId: string) => Promise<unknown>;
    hooks: {
      create: (data: {
        runId?: string;
        workflowName?: string;
        signalName?: string;
        token: string;
        metadata?: any;
      }) => Promise<unknown>;
      execute: (token: string, payload: any) => Promise<unknown>;
      get: (id: string) => Promise<unknown>;
      getByToken: (token: string) => Promise<unknown>;
      list: (runId: string) => Promise<unknown>;
      dispose: (id: string) => Promise<unknown>;
    };
  };
  /**
   * Calls a Gate (custom API endpoint) defined in the backend.
   * @param name - The name of the gate to call.
   * @param data - The data payload to send (optional).
   * @param options - Additional fetch options (optional).
   * @returns A promise that resolves to the fetch Response.
   */
  gate(name: string, data?: any, options?: RequestInit): Promise<Response>;
}
/**
 * Global registry for workflow classes and definitions.
 * Maps workflow names to their corresponding class constructors or implementations.
 */
export declare const WorkflowRegistry: Map<string, any>;
/**
 * Base class for all workflow implementations.
 * Provides the core logic for step execution, state management, idempotency, and signal handling.
 * Workflows extending this class (or using the functional wrapper) inherit these capabilities.
 */
export declare class WorkflowBase {
  /** The RocketBase client instance used for API calls. */
  client: RocketBaseClient;
  /** Unique identifier for the current workflow run. */
  runId: string;
  /** Name of the workflow. */
  workflowName: string;
  /** Options used for the workflow execution. */
  workflowOptions: WorkflowOptions;
  /** History of step results, indexed by step correlation ID. */
  history: Map<string, unknown>;
  /** Set of successfully completed step IDs. */
  completedSteps: Set<string>;
  /** Stack of rollback method names to call if the workflow fails. */
  rollbackStack: string[];
  /** Map tracking the number of attempts for each step ID. */
  stepAttempts: Map<string, number>;
  /** Counter for generating sequential IDs for steps and sleeps. */
  callCounter: number;
  /** Buffered signal data, indexed by signal name. */
  signalQueues: Map<string, any[]>;
  /** Cursors for signal queues to handle multiple waits for the same signal. */
  signalCursors: Map<string, number>;
  /** Flag indicating if the workflow is currently suspended. */
  isSuspended: boolean;
  /** Set of step IDs that have been invoked during the current execution. */
  invokedSteps: Set<string>;
  /** Set of event IDs that have been emitted to the backend. */
  emittedEvents: Set<string>;
  /**
   * Creates a new instance of WorkflowBase.
   * @param client - Optional RocketBase client instance.
   */
  constructor(client?: RocketBaseClient);
  /**
   * Executes multiple steps in parallel.
   * @param steps - An array of functions returning promises to be executed concurrently.
   * @returns An array of results from the executed steps.
   */
  parallel<T>(steps: (() => Promise<T>)[]): Promise<T[]>;
  /**
   * Generates a sequential ID for steps or sleeps that don't have a manual ID.
   * NOTE: This is order-dependent. Adding or removing steps will shift these IDs
   * and can break long-running workflows during replay.
   * @param prefix - The prefix for the ID (e.g., "step", "sleep").
   * @returns A generated unique ID.
   */
  getSequentialId(prefix: string): string;
  /**
   * Pauses execution for a specified duration.
   * This method supports idempotency and replay.
   * @param duration - The duration to sleep in milliseconds or as a string (e.g., "1s", "5m").
   * @returns A promise that resolves when the sleep is completed.
   * @throws {WorkflowSuspension} When the sleep starts, suspending execution until the duration passes.
   */
  sleep(duration: number | string): Promise<void>;
  /**
   * Pauses execution until a specific signal is received.
   * This method supports idempotency and replay.
   * @param name - The name of the signal to wait for.
   * @returns The data payload associated with the signal.
   * @throws {WorkflowSuspension} When waiting for the signal, suspending execution until it arrives.
   */
  waitForSignal<T = unknown>(name: string): Promise<T>;
  /**
   * Executes the rollback stack in reverse order.
   * This is called when a workflow fails and needs to compensate for completed steps.
   * @param error - The error that triggered the rollback.
   * @returns A promise that resolves when the rollback is complete.
   */
  runRollback(error: unknown): Promise<void>;
  /**
   * Reconstructs the workflow state from a list of events.
   * Used when resuming a workflow or replaying history.
   * @param events - The list of events from the workflow run.
   */
  rebuildState(events: WorkflowEvent[]): void;
  /**
   * Executes a single step within the workflow with idempotency, retries, and rollback support.
   * @param id - The unique identifier for the step.
   * @param fn - The function implementing the step logic.
   * @param args - Arguments to pass to the function.
   * @param options - Options for retries, rollback, and timeout.
   * @returns The result of the step execution.
   */
  executeStep<T>(
    id: string,
    fn: (...args: any[]) => Promise<T>,
    args: any[],
    options?: StepOptions,
    name?: string,
  ): Promise<T>;
}
/**
 * Decorator to define a class as a Workflow.
 * Wraps the class to handle initialization, execution, and state management via RocketBase.
 * @param name - The unique name of the workflow.
 * @param options - Configuration options for the workflow (e.g., max events, timeout).
 * @returns A class decorator function.
 */
export declare function Workflow(
  name: string,
  options?: WorkflowOptions,
): (constructor: Function) => void;
/**
 * Decorator to define a method as a Step within a Workflow.
 * Wraps the method to provide idempotency, retries, and rollback capabilities.
 * @param id - The unique identifier for the step.
 * @param options - Options for retries, rollback methods, and timeout.
 * @returns A method decorator function.
 */
export declare function Step(
  id: string,
  options?: StepOptions,
): (_target: any, _propertyKey: string, descriptor: PropertyDescriptor) => void;
/**
 * Worker class responsible for polling and executing workflow jobs.
 * Connects to the RocketBase backend via WebSocket to receive job assignments.
 */
export declare class WorkflowWorker {
  private client;
  private active;
  private workflowNames;
  private stopCallback;
  private activeJobs;
  private unsubscribers;
  /**
   * Creates a new instance of WorkflowWorker.
   * @param client - The RocketBase client instance.
   */
  constructor(client: RocketBaseClient);
  /**
   * Starts the worker for one or more workflows.
   * @param workflowName - The name of the workflow(s) to process.
   * @param options - Options for concurrency and resuming pending runs.
   * @returns A promise that resolves when the worker is stopped.
   */
  start(workflowName: string | string[], options?: {
    concurrency?: number;
    resume?: boolean;
  }): Promise<void>;
  /**
   * Resumes pending and running runs for a workflow.
   * @param workflowName - The name of the workflow.
   */
  private resumePending;
  /**
   * Stops the worker, closing the connection and waiting for active jobs to complete.
   * @returns A promise that resolves when the worker is fully stopped.
   */
  stop(): Promise<void>;
  /**
   * Processes a single job assignment.
   * Reconstructs the workflow state and attempts to execute it.
   * @param job - The job data received from the server.
   * @returns A promise that resolves when the job processing is complete.
   */
  processJob(job: WorkflowJob): Promise<void>;
}
/**
 * Error thrown to stop the rollback process in a workflow.
 * When thrown inside a rollback handler, it prevents further rollback steps from executing.
 */
export declare class StopRollback extends Error {
  /**
   * Creates a new StopRollback error.
   * @param message - The error message.
   */
  constructor(message?: string);
}
/**
 * Defines a functional workflow.
 * @param name - The unique name of the workflow.
 * @param options - Configuration options for the workflow.
 * @returns An object with a `run` method to define workflow logic.
 */
export declare function workflow(name: string, options?: WorkflowOptions): {
  run: (
    fn: (ctx: WorkflowContext, ...args: any[]) => Promise<any>,
  ) => typeof WorkflowBase;
};
/**
 * Defines a step within a functional workflow.
 * Can be used to wrap a function or define a block of code as a step.
 * @param idOrFn - The step ID (string) or function to wrap.
 * @param fnOrOptions - The function (if ID was first) or options (if function was first).
 * @param options - Options for retries, rollback, etc. (if ID was first).
 * @returns A wrapped function that executes as a workflow step.
 */
export declare function step<T extends (...args: any[]) => Promise<any>>(
  idOrFn: string | T,
  fnOrOptions?: T | StepOptions,
  options?: StepOptions,
): T;
/**
 * Internal error used to signal that a workflow execution is suspended.
 * This is caught by the worker to save state and exit the execution loop.
 */
export declare class WorkflowSuspension extends Error {
  /**
   * Creates a new WorkflowSuspension error.
   * @param message - The reason for suspension.
   */
  constructor(message?: string);
}

export {};
