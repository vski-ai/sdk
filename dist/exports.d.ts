// Generated by dts-bundle-generator v9.5.1

export interface SubscriptionOptions {
  lastId?: string;
  group?: string;
}
export interface RealtimeEvent {
  action: "create" | "update" | "delete";
  record: any;
}
export interface WorkflowContext {
  runId: string;
  workflowName: string;
  history: Map<string, any>;
  stepAttempts: Map<string, number>;
  sleep(duration: number | string): Promise<void>;
  waitForSignal<T = any>(name: string): Promise<T>;
  parallel<T>(steps: (() => Promise<T>)[]): Promise<T[]>;
}
export declare class RocketBaseClient {
  baseUrl: string;
  private token;
  private apiKey;
  dbName: string;
  private adminDbName;
  private realtimeSocket;
  private subscriptions;
  constructor(baseUrl?: string);
  getToken(): string;
  setToken(token: string | null): void;
  setApiKey(key: string | null): void;
  setDb(db: string): void;
  setAdminDb(db: string): void;
  close(): void;
  private get headers();
  private get adminHeaders();
  get settings(): {
    databases: {
      list: () => Promise<any>;
      create: (data: {
        name: string;
        extensions?: string[];
        initScript?: string;
      }) => Promise<any>;
      delete: (name: string) => Promise<boolean>;
    };
    collections: {
      create: (data: any) => Promise<any>;
      update: (id: string, data: any) => Promise<any>;
      delete: (id: string) => Promise<boolean>;
      getList: () => Promise<any>;
    };
  };
  get auth(): {
    login: (email: string, pass: string) => Promise<any>;
    register: (data: any) => Promise<any>;
    me: () => Promise<any>;
    listMethods: () => Promise<any>;
    authViaOAuth2: (
      provider: string,
      code: string,
      redirectUrl: string,
    ) => Promise<any>;
  };
  get keys(): {
    generate: (data: any) => Promise<any>;
  };
  get admins(): {
    authWithPassword: (identity: string, password: string) => Promise<any>;
    init: (data: any) => Promise<any>;
    hasAdmins: () => Promise<any>;
    me: () => Promise<any>;
  };
  get cron(): {
    list: () => Promise<any>;
    create: (data: any) => Promise<any>;
    delete: (name: string) => Promise<boolean>;
  };
  get webhookLogs(): {
    list: (filters?: {
      collection?: string;
      status?: string;
      page?: number;
      perPage?: number;
    }) => Promise<any>;
  };
  get workflowStats(): {
    get: () => Promise<any>;
  };
  collection(name: string): {
    getList: (page?: number, perPage?: number, options?: {
      filter?: string;
      expand?: string;
    }) => Promise<any>;
    getOne: (id: string, options?: {
      expand?: string;
    }) => Promise<any>;
    search: (q: string, options?: {
      page?: number;
      perPage?: number;
      expand?: string;
      snippet?: boolean;
    }) => Promise<any>;
    getView: (slug: string, options?: {
      page?: number;
      perPage?: number;
      expand?: string;
      filter?: string;
      sort?: string;
    }) => Promise<any>;
    create: (data: any) => Promise<any>;
    update: (id: string, data: any) => Promise<any>;
    bulkUpdate: (ids: string[], data: any) => Promise<any>;
    delete: (id: string) => Promise<boolean>;
    bulkDelete: (ids: string[]) => Promise<any>;
    authWithPassword: (identity: string, password: string) => Promise<any>;
    subscribe: (
      callback: (e: RealtimeEvent) => void,
      options?: SubscriptionOptions,
    ) => () => void;
  };
  private connectRealtime;
  get migrations(): {
    getList: (page?: number, perPage?: number, options?: {
      filter?: string;
      sort?: string;
    }) => Promise<any>;
    create: (data: {
      name: string;
      appliedAt: string;
      batch?: number;
    }) => Promise<any>;
    delete: (id: string) => Promise<boolean>;
    run: (migrations: {
      name: string;
      up: (sdk: RocketBaseClient) => Promise<void>;
    }[]) => Promise<void>;
  };
  get workflow(): {
    createRun: (data: any) => Promise<any>;
    trigger: (
      workflowName: string,
      input: any[],
      options?: any,
    ) => Promise<any>;
    resume: (runId: string) => Promise<any>;
    getRun: (runId: string) => Promise<any>;
    updateRun: (runId: string, data: any) => Promise<any>;
    listRuns: (params?: {
      workflowName?: string;
      status?: string;
      limit?: number;
      cursor?: string;
    }) => Promise<any>;
    createStep: (runId: string, data: any) => Promise<any>;
    updateStep: (runId: string, stepId: string, data: any) => Promise<any>;
    createEvent: (runId: string, data: any) => Promise<any>;
    listEvents: (runId: string) => Promise<any>;
    pollQueue: (queueName: string) => Promise<any>;
    sendSignal: (
      runId: string,
      signalName: string,
      data: any,
      correlationId?: string,
    ) => Promise<boolean>;
    queueMessage: (queueName: string, message: any, opts?: any) => Promise<any>;
    ack: (messageId: string) => Promise<any>;
    nack: (messageId: string) => Promise<any>;
    touch: (messageId: string) => Promise<any>;
    hooks: {
      create: (runId: string, data: any) => Promise<any>;
      get: (id: string) => Promise<any>;
      getByToken: (token: string) => Promise<any>;
      list: (runId: string) => Promise<any>;
      dispose: (id: string) => Promise<any>;
    };
  };
  gate(name: string, data?: any, options?: RequestInit): Promise<Response>;
}
export declare const WorkflowRegistry: Map<string, any>;
export declare class WorkflowBase {
  client: RocketBaseClient;
  runId: string;
  workflowName: string;
  history: Map<string, any>;
  completedSteps: Set<string>;
  rollbackStack: string[];
  stepAttempts: Map<string, number>;
  callCounter: number;
  signalQueues: Map<string, any[]>;
  signalCursors: Map<string, number>;
  isSuspended: boolean;
  invokedSteps: Set<string>;
  constructor(client?: RocketBaseClient);
  parallel<T>(steps: (() => Promise<T>)[]): Promise<T[]>;
  /**
   * Generates a sequential ID for steps or sleeps that don't have a manual ID.
   * NOTE: This is order-dependent. Adding or removing steps will shift these IDs
   * and can break long-running workflows during replay.
   */
  getSequentialId(prefix: string): string;
  sleep(duration: number | string): Promise<void>;
  waitForSignal<T = any>(name: string): Promise<T>;
  runRollback(error: any): Promise<void>;
  rebuildState(events: any[]): void;
  executeStep<T>(
    id: string,
    fn: (...args: any[]) => Promise<T>,
    args: any[],
    options?: {
      retries?: number;
      rollback?: string[];
      timeout?: string;
    },
  ): Promise<T>;
}
export declare function Workflow(name: string, options?: {
  maxEvents?: number;
  executionTimeout?: number;
}): (constructor: Function) => void;
export declare function Step(id: string, options?: {
  retries?: number;
  rollback?: string[];
  timeout?: string;
}): (
  _target: any,
  _propertyKey: string,
  descriptor: PropertyDescriptor,
) => void;
export declare class WorkflowWorker {
  private client;
  private socket;
  private active;
  private workflowName;
  private stopCallback;
  private activeJobs;
  constructor(client: RocketBaseClient);
  start(workflowName: string, options?: {
    concurrency?: number;
    resume?: boolean;
  }): Promise<void>;
  private resumePending;
  stop(): Promise<void>;
  private connect;
  processJob(job: any): Promise<void>;
}
export declare class StopRollback extends Error {
  constructor(message?: string);
}
export declare function workflow(name: string, options?: {
  maxEvents?: number;
  executionTimeout?: number;
}): {
  run: (fn: (ctx: WorkflowContext, ...args: any[]) => Promise<any>) => {
    new (client?: RocketBaseClient): {
      workflowName: string;
      workflowOptions: {
        maxEvents?: number;
        executionTimeout?: number;
      };
      run(...args: any[]): Promise<any>;
      client: RocketBaseClient;
      runId: string;
      history: Map<string, any>;
      completedSteps: Set<string>;
      rollbackStack: string[];
      stepAttempts: Map<string, number>;
      callCounter: number;
      signalQueues: Map<string, any[]>;
      signalCursors: Map<string, number>;
      isSuspended: boolean;
      invokedSteps: Set<string>;
      parallel<T>(steps: (() => Promise<T>)[]): Promise<T[]>;
      getSequentialId(prefix: string): string;
      sleep(duration: number | string): Promise<void>;
      waitForSignal<T = any>(name: string): Promise<T>;
      runRollback(error: any): Promise<void>;
      rebuildState(events: any[]): void;
      executeStep<T>(
        id: string,
        fn: (...args: any[]) => Promise<T>,
        args: any[],
        options?: {
          retries?: number;
          rollback?: string[];
          timeout?: string;
        },
      ): Promise<T>;
    };
    workflowName: string;
  };
};
export declare function step<T extends (...args: any[]) => Promise<any>>(
  idOrFn: string | T,
  fnOrOptions?: T | {
    retries?: number;
    rollback?: string[];
    timeout?: string;
  },
  options?: {
    retries?: number;
    rollback?: string[];
    timeout?: string;
  },
): T;

export {};
