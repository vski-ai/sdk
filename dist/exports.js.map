{
  "version": 3,
  "sources": ["../src/registry.ts", "../src/client.ts", "../src/suspension.ts", "../src/workflow-base.ts", "../src/decorators.ts", "../src/worker.ts", "../src/errors.ts", "../src/context.ts", "../src/functional.ts"],
  "sourcesContent": ["export const WorkflowRegistry = new Map<string, any>();\n", "// Copyright (c) 2025 Anton A Nesterov <an+vski@vski.sh>, VSKI License\n//\n\nimport type { RealtimeEvent, SubscriptionOptions } from \"./types.ts\";\nimport { WorkflowRegistry } from \"./registry.ts\";\n\nexport class RocketBaseClient {\n  public baseUrl: string;\n  private token: string | null = null;\n  private apiKey: string | null = null;\n  public dbName: string = \"postgres\"; // Changed to public for Worker access\n  private adminDbName: string = \"postgres\";\n  private realtimeSocket: WebSocket | null = null;\n  private subscriptions = new Map<\n    string,\n    {\n      callback: (e: RealtimeEvent) => void;\n      options?: SubscriptionOptions;\n    }\n  >();\n\n  constructor(baseUrl: string = \"http://127.0.0.1:3000\") {\n    this.baseUrl = baseUrl.endsWith(\"/\") ? baseUrl.slice(0, -1) : baseUrl;\n    if (typeof window !== \"undefined\") {\n      this.token = localStorage.getItem(\"pb_auth_token\");\n      this.apiKey = localStorage.getItem(\"rb_api_key\");\n    }\n  }\n\n  getToken() {\n    return this.token;\n  }\n\n  setToken(token: string | null) {\n    this.token = token;\n    if (typeof window !== \"undefined\") {\n      if (token) {\n        localStorage.setItem(\"pb_auth_token\", token);\n      } else {\n        localStorage.removeItem(\"pb_auth_token\");\n      }\n    }\n    if (this.realtimeSocket) {\n      this.realtimeSocket.close();\n    }\n  }\n\n  setApiKey(key: string | null) {\n    this.apiKey = key;\n    if (typeof window !== \"undefined\") {\n      if (key) {\n        localStorage.setItem(\"rb_api_key\", key);\n      } else {\n        localStorage.removeItem(\"rb_api_key\");\n      }\n    }\n  }\n\n  setDb(db: string) {\n    this.dbName = db;\n    if (this.realtimeSocket) {\n      this.realtimeSocket.close();\n    }\n  }\n\n  setAdminDb(db: string) {\n    this.adminDbName = db;\n    if (this.realtimeSocket) {\n      this.realtimeSocket.close();\n    }\n  }\n\n  close() {\n    if (this.realtimeSocket) {\n      this.realtimeSocket.close();\n      this.realtimeSocket = null;\n    }\n    this.subscriptions.clear();\n  }\n\n  private get headers() {\n    const h: any = {\n      \"Content-Type\": \"application/json\",\n      \"x-dbname\": this.dbName,\n    };\n    if (this.token) h[\"Authorization\"] = `Bearer ${this.token}`;\n    if (this.apiKey) h[\"X-API-Key\"] = this.apiKey;\n    return h;\n  }\n\n  private get adminHeaders() {\n    const h: any = {\n      \"Content-Type\": \"application/json\",\n      \"x-dbname\": this.adminDbName,\n    };\n    if (this.token) h[\"Authorization\"] = `Bearer ${this.token}`;\n    if (this.apiKey) h[\"X-API-Key\"] = this.apiKey;\n    return h;\n  }\n\n  get settings() {\n    // @ts-ignore:\n    const self = this;\n    return {\n      databases: {\n        list: async () => {\n          const res = await fetch(`${self.baseUrl}/api/databases`, {\n            headers: self.headers,\n          });\n          if (!res.ok) throw new Error(await res.text());\n          return res.json();\n        },\n        create: async (data: {\n          name: string;\n          extensions?: string[];\n          initScript?: string;\n        }) => {\n          const res = await fetch(`${self.baseUrl}/api/databases`, {\n            method: \"POST\",\n            headers: self.headers,\n            body: JSON.stringify(data),\n          });\n          if (!res.ok) throw new Error(await res.text());\n          return res.json();\n        },\n        delete: async (name: string) => {\n          const res = await fetch(`${self.baseUrl}/api/databases/${name}`, {\n            method: \"DELETE\",\n            headers: self.headers,\n          });\n          if (!res.ok) throw new Error(await res.text());\n          await res.text();\n          return true;\n        },\n      },\n      collections: {\n        create: async (data: any) => {\n          const res = await fetch(`${self.baseUrl}/api/collections`, {\n            method: \"POST\",\n            headers: self.headers,\n            body: JSON.stringify(data),\n          });\n          if (!res.ok) throw new Error(await res.text());\n          return res.json();\n        },\n        update: async (id: string, data: any) => {\n          const res = await fetch(`${self.baseUrl}/api/collections/${id}`, {\n            method: \"PATCH\",\n            headers: self.headers,\n            body: JSON.stringify(data),\n          });\n          if (!res.ok) throw new Error(await res.text());\n          return res.json();\n        },\n        delete: async (id: string) => {\n          const res = await fetch(`${self.baseUrl}/api/collections/${id}`, {\n            method: \"DELETE\",\n            headers: self.headers,\n          });\n          if (!res.ok) throw new Error(await res.text());\n          await res.text();\n          return true;\n        },\n        getList: async () => {\n          const res = await fetch(`${self.baseUrl}/api/collections`, {\n            headers: self.headers,\n          });\n          if (!res.ok) throw new Error(await res.text());\n          return res.json();\n        },\n      },\n    };\n  }\n\n  get auth() {\n    const self = this;\n    return {\n      // Login using the configured default auth collection\n      login: async (email: string, pass: string) => {\n        const res = await fetch(`${self.baseUrl}/api/auth/login`, {\n          method: \"POST\",\n          headers: self.headers,\n          body: JSON.stringify({ identity: email, password: pass }),\n        });\n        if (!res.ok) throw new Error(await res.text());\n        const data = await res.json();\n        self.setToken(data.token);\n        return data;\n      },\n      // Register a new user in the configured default auth collection\n      register: async (data: any) => {\n        const res = await fetch(`${self.baseUrl}/api/auth/register`, {\n          method: \"POST\",\n          headers: self.headers,\n          body: JSON.stringify(data),\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n      // Get the profile of the currently logged in user\n      me: async () => {\n        // This assumes the token is valid\n        // We might need an endpoint /api/auth/me that resolves the user from the token\n        // independent of collection\n        const res = await fetch(`${self.baseUrl}/api/auth/me`, {\n          headers: self.headers,\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n      // List available auth methods (OAuth providers)\n      listMethods: async () => {\n        const res = await fetch(`${self.baseUrl}/api/auth/methods`, {\n          headers: self.headers,\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n      // Login via OAuth2 code\n      authViaOAuth2: async (\n        provider: string,\n        code: string,\n        redirectUrl: string,\n      ) => {\n        const res = await fetch(`${self.baseUrl}/api/auth/oauth2-login`, {\n          method: \"POST\",\n          headers: self.headers,\n          body: JSON.stringify({ provider, code, redirectUrl }),\n        });\n        if (!res.ok) throw new Error(await res.text());\n        const data = await res.json();\n        self.setToken(data.token);\n        return data;\n      },\n    };\n  }\n\n  get keys() {\n    const self = this;\n    return {\n      generate: async (data: any) => {\n        const res = await fetch(`${self.baseUrl}/api/keys`, {\n          method: \"POST\",\n          headers: self.adminHeaders,\n          body: JSON.stringify(data),\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n    };\n  }\n\n  get admins() {\n    const self = this;\n    return {\n      authWithPassword: async (identity: string, password: string) => {\n        const res = await fetch(\n          `${self.baseUrl}/api/admins/auth-with-password`,\n          {\n            method: \"POST\",\n            headers: self.headers,\n            body: JSON.stringify({ identity, password }),\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        const data = await res.json();\n        self.setToken(data.token);\n        return data;\n      },\n      init: async (data: any) => {\n        const res = await fetch(`${self.baseUrl}/api/admins/init`, {\n          method: \"POST\",\n          headers: self.headers,\n          body: JSON.stringify(data),\n        });\n        if (!res.ok) throw new Error(await res.text());\n        const resData = await res.json();\n        self.setToken(resData.token);\n        return resData;\n      },\n      hasAdmins: async () => {\n        const res = await fetch(`${self.baseUrl}/api/admins/has-admins`, {\n          headers: self.headers,\n        });\n        if (!res.ok) {\n          await res.text();\n          return { hasAdmins: false };\n        }\n        return res.json();\n      },\n      me: async () => {\n        const res = await fetch(`${self.baseUrl}/api/admins/me`, {\n          headers: self.adminHeaders,\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n    };\n  }\n\n  get cron() {\n    const self = this;\n    return {\n      list: async () => {\n        const res = await fetch(`${self.baseUrl}/api/cron`, {\n          headers: self.headers,\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n      create: async (data: any) => {\n        const res = await fetch(`${self.baseUrl}/api/cron`, {\n          method: \"POST\",\n          headers: self.headers,\n          body: JSON.stringify(data),\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n      delete: async (name: string) => {\n        const res = await fetch(`${self.baseUrl}/api/cron/${name}`, {\n          method: \"DELETE\",\n          headers: self.headers,\n        });\n        if (!res.ok) throw new Error(await res.text());\n        await res.text();\n        return true;\n      },\n    };\n  }\n\n  get webhookLogs() {\n    const self = this;\n    return {\n      list: async (\n        filters: {\n          collection?: string;\n          status?: string;\n          page?: number;\n          perPage?: number;\n        } = {},\n      ) => {\n        const params = new URLSearchParams();\n        Object.entries(filters).forEach(([key, value]) => {\n          if (value !== undefined && value !== \"\") {\n            params.append(key, value.toString());\n          }\n        });\n        const res = await fetch(\n          `${self.baseUrl}/api/webhooks/logs?${params.toString()}`,\n          {\n            headers: self.headers,\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n    };\n  }\n\n  get workflowStats() {\n    const self = this;\n    return {\n      get: async () => {\n        const res = await fetch(`${self.baseUrl}/api/workflows/stats`, {\n          headers: self.headers,\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n    };\n  }\n\n  collection(name: string) {\n    const self = this;\n\n    return {\n      getList: async (\n        page = 1,\n        perPage = 30,\n        options: { filter?: string; expand?: string } = {},\n      ) => {\n        const params = new URLSearchParams({\n          page: String(page),\n          perPage: String(perPage),\n        });\n        if (options.filter) params.append(\"filter\", options.filter);\n        if (options.expand) params.append(\"expand\", options.expand);\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records?${params.toString()}`,\n          { headers: self.headers },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      getOne: async (id: string, options: { expand?: string } = {}) => {\n        const params = new URLSearchParams();\n        if (options.expand) params.append(\"expand\", options.expand);\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/${id}?${params.toString()}`,\n          { headers: self.headers },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      search: async (\n        q: string,\n        options: {\n          page?: number;\n          perPage?: number;\n          expand?: string;\n          snippet?: boolean;\n        } = {},\n      ) => {\n        const params = new URLSearchParams({ q });\n        if (options.page) params.append(\"page\", String(options.page));\n        if (options.perPage) params.append(\"perPage\", String(options.perPage));\n        if (options.expand) params.append(\"expand\", options.expand);\n        if (options.snippet) params.append(\"snippet\", \"true\");\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/search?${params.toString()}`,\n          { headers: self.headers },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      getView: async (\n        slug: string,\n        options: {\n          page?: number;\n          perPage?: number;\n          expand?: string;\n          filter?: string;\n          sort?: string;\n        } = {},\n      ) => {\n        const params = new URLSearchParams();\n        if (options.page) params.append(\"page\", String(options.page));\n        if (options.perPage) params.append(\"perPage\", String(options.perPage));\n        if (options.expand) params.append(\"expand\", options.expand);\n        if (options.filter) params.append(\"filter\", options.filter);\n        if (options.sort) params.append(\"sort\", options.sort);\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/views/${slug}?${params.toString()}`,\n          { headers: self.headers },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      create: async (data: any) => {\n        const isFormData = data instanceof FormData;\n        const h = { ...self.headers };\n        if (isFormData) delete h[\"Content-Type\"];\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records`,\n          {\n            method: \"POST\",\n            headers: h,\n            body: isFormData ? data : JSON.stringify(data),\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      update: async (id: string, data: any) => {\n        const isFormData = data instanceof FormData;\n        const h = { ...self.headers };\n        if (isFormData) delete h[\"Content-Type\"];\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/${id}`,\n          {\n            method: \"PATCH\",\n            headers: h,\n            body: isFormData ? data : JSON.stringify(data),\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      bulkUpdate: async (ids: string[], data: any) => {\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/bulk`,\n          {\n            method: \"PATCH\",\n            headers: self.headers,\n            body: JSON.stringify({ ids, data }),\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      delete: async (id: string) => {\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/${id}`,\n          {\n            method: \"DELETE\",\n            headers: self.headers,\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        await res.text();\n        return true;\n      },\n\n      bulkDelete: async (ids: string[]) => {\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/bulk`,\n          {\n            method: \"DELETE\",\n            headers: self.headers,\n            body: JSON.stringify({ ids }),\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      authWithPassword: async (identity: string, password: string) => {\n        if (name === \"_superusers\") {\n          return self.admins.authWithPassword(identity, password);\n        }\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/auth-with-password`,\n          {\n            method: \"POST\",\n            headers: self.headers,\n            body: JSON.stringify({ identity, password }),\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        const data = await res.json();\n        self.setToken(data.token);\n        return data;\n      },\n\n      subscribe: (\n        callback: (e: RealtimeEvent) => void,\n        options?: SubscriptionOptions,\n      ) => {\n        self.subscriptions.set(name, { callback, options });\n        self.connectRealtime();\n\n        if (self.realtimeSocket?.readyState === 1) {\n          self.realtimeSocket.send(\n            JSON.stringify({ type: \"SUBSCRIBE\", collection: name, ...options }),\n          );\n        }\n\n        return () => {\n          self.subscriptions.delete(name);\n        };\n      },\n    };\n  }\n\n  private connectRealtime() {\n    if (typeof WebSocket === \"undefined\") return;\n    if (\n      this.realtimeSocket &&\n      (this.realtimeSocket.readyState === 0 ||\n        this.realtimeSocket.readyState === 1)\n    ) {\n      return;\n    }\n\n    const wsUrl = this.baseUrl.replace(\"http\", \"ws\") +\n      \"/api/realtime\" +\n      `?db=${this.dbName}` +\n      (this.token ? `&auth=${this.token}` : \"\");\n    this.realtimeSocket = new WebSocket(wsUrl);\n\n    this.realtimeSocket.onopen = () => {\n      this.subscriptions.forEach((sub, name) => {\n        this.realtimeSocket?.send(\n          JSON.stringify({\n            type: \"SUBSCRIBE\",\n            collection: name,\n            ...sub.options,\n          }),\n        );\n      });\n    };\n\n    this.realtimeSocket.onmessage = (event) => {\n      const msg = JSON.parse(event.data);\n      const sub = this.subscriptions.get(msg.collection);\n      if (!sub || !msg.events) return;\n\n      msg.events.forEach((e: any) => {\n        try {\n          sub.callback(e.data);\n          if (!sub.options?.group) {\n            sub.options = { ...sub.options, lastId: e.id };\n          }\n          if (e.ackId && sub.options?.group) {\n            this.realtimeSocket?.send(\n              JSON.stringify({\n                type: \"ACK\",\n                collection: msg.collection,\n                id: e.ackId,\n                group: sub.options.group,\n              }),\n            );\n          }\n        } catch (err) {\n          console.error(\"Error handling realtime event:\", err);\n        }\n      });\n    };\n\n    this.realtimeSocket.onclose = () => {\n      setTimeout(() => this.connectRealtime(), 3000);\n    };\n  }\n\n  get migrations() {\n    const self = this;\n    const name = \"_migrations\";\n    return {\n      getList: async (\n        page = 1,\n        perPage = 500,\n        options: { filter?: string; sort?: string } = {},\n      ) => {\n        const params = new URLSearchParams({\n          page: String(page),\n          perPage: String(perPage),\n        });\n        if (options.filter) params.append(\"filter\", options.filter);\n        if (options.sort) params.append(\"sort\", options.sort);\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records?${params.toString()}`,\n          { headers: self.adminHeaders },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n      create: async (data: {\n        name: string;\n        appliedAt: string;\n        batch?: number;\n      }) => {\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records`,\n          {\n            method: \"POST\",\n            headers: self.adminHeaders,\n            body: JSON.stringify(data),\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n      delete: async (id: string) => {\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/${id}`,\n          {\n            method: \"DELETE\",\n            headers: self.adminHeaders,\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        await res.text();\n        return true;\n      },\n      run: async (\n        migrations: {\n          name: string;\n          up: (sdk: RocketBaseClient) => Promise<void>;\n        }[],\n      ) => {\n        const applied = await self.migrations.getList(1, 500);\n        const appliedNames = new Set(applied.items.map((m: any) => m.name));\n\n        for (const mig of migrations) {\n          if (!appliedNames.has(mig.name)) {\n            console.log(`[Migrations] Applying: ${mig.name}`);\n            await mig.up(self);\n            await self.migrations.create({\n              name: mig.name,\n              appliedAt: new Date().toISOString(),\n              batch: 1, // For now\n            });\n          }\n        }\n      },\n    };\n  }\n\n  get workflow() {\n    const self = this;\n\n    const base = `${self.baseUrl}/api/workflows`;\n\n    return {\n      createRun: async (data: any) => {\n        const res = await fetch(`${base}/runs`, {\n          method: \"POST\",\n\n          headers: self.headers,\n\n          body: JSON.stringify(data),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      trigger: async (\n        workflowName: string,\n        input: any[],\n        options: any = {},\n      ) => {\n        const Class = WorkflowRegistry.get(workflowName);\n        const defaultOptions = Class?.prototype?.workflowOptions || {};\n        const mergedOptions = { ...defaultOptions, ...options };\n\n        const run = await self.workflow.createRun({\n          deploymentId: mergedOptions.deploymentId || \"sdk\",\n\n          workflowName,\n\n          input,\n          ...mergedOptions,\n        });\n\n        await self.workflow.queueMessage(`__wkf_workflow_${workflowName}`, {\n          type: \"workflow_start\",\n\n          runId: run.runId,\n\n          workflowName,\n\n          input,\n        });\n\n        return run;\n      },\n\n      resume: async (runId: string) => {\n        const run = await self.workflow.getRun(runId);\n\n        await self.workflow.queueMessage(`__wkf_workflow_${run.workflowName}`, {\n          type: \"resume\",\n\n          runId: run.runId,\n\n          workflowName: run.workflowName,\n\n          input: run.input,\n        });\n\n        return run;\n      },\n\n      getRun: async (runId: string) => {\n        const res = await fetch(`${base}/runs/${runId}`, {\n          headers: self.headers,\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      updateRun: async (runId: string, data: any) => {\n        const res = await fetch(`${base}/runs/${runId}`, {\n          method: \"PATCH\",\n\n          headers: self.headers,\n\n          body: JSON.stringify(data),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      listRuns: async (\n        params: {\n          workflowName?: string;\n\n          status?: string;\n\n          limit?: number;\n\n          cursor?: string;\n        } = {},\n      ) => {\n        const p = new URLSearchParams();\n\n        if (params.workflowName) p.append(\"workflowName\", params.workflowName);\n\n        if (params.status) p.append(\"status\", params.status);\n\n        if (params.limit) p.append(\"limit\", String(params.limit));\n\n        if (params.cursor) p.append(\"cursor\", params.cursor);\n\n        const res = await fetch(`${base}/runs?${p.toString()}`, {\n          headers: self.headers,\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      createStep: async (runId: string, data: any) => {\n        const res = await fetch(`${base}/steps`, {\n          method: \"POST\",\n\n          headers: self.headers,\n\n          body: JSON.stringify({ runId, ...data }),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      updateStep: async (runId: string, stepId: string, data: any) => {\n        const res = await fetch(`${base}/steps/${runId}/${stepId}`, {\n          method: \"PATCH\",\n\n          headers: self.headers,\n\n          body: JSON.stringify(data),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      createEvent: async (runId: string, data: any) => {\n        const res = await fetch(`${base}/events`, {\n          method: \"POST\",\n\n          headers: self.headers,\n\n          body: JSON.stringify({ runId, ...data }),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      listEvents: async (runId: string) => {\n        const res = await fetch(`${base}/runs/${runId}/events`, {\n          headers: self.headers,\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      pollQueue: async (queueName: string) => {\n        const res = await fetch(`${base}/queue/${queueName}`, {\n          headers: self.headers,\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        const text = await res.text();\n\n        return text ? JSON.parse(text) : null;\n      },\n\n      sendSignal: async (\n        runId: string,\n        signalName: string,\n        data: any,\n        correlationId?: string,\n      ) => {\n        // 1. Create signal event\n\n        await self.workflow.createEvent(runId, {\n          eventType: \"signal_received\",\n\n          correlationId: correlationId ||\n            `signal-${signalName}-${crypto.randomUUID()}`, // Deterministic ID for the signal\n\n          payload: { name: signalName, data },\n        });\n\n        // 2. Queue workflow for execution\n\n        const run = await self.workflow.getRun(runId);\n\n        await self.workflow.queueMessage(`__wkf_workflow_${run.workflowName}`, {\n          type: \"signal\",\n\n          runId: runId,\n\n          workflowName: run.workflowName,\n\n          input: run.input,\n        });\n\n        return true;\n      },\n\n      queueMessage: async (queueName: string, message: any, opts?: any) => {\n        const res = await fetch(`${base}/queue`, {\n          method: \"POST\",\n\n          headers: self.headers,\n\n          body: JSON.stringify({ queueName, message, opts }),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      ack: async (messageId: string) => {\n        const res = await fetch(`${base}/queue/ack`, {\n          method: \"POST\",\n\n          headers: self.headers,\n\n          body: JSON.stringify({ messageId }),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      nack: async (messageId: string) => {\n        const res = await fetch(`${base}/queue/nack`, {\n          method: \"POST\",\n\n          headers: self.headers,\n\n          body: JSON.stringify({ messageId }),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      touch: async (messageId: string) => {\n        const res = await fetch(`${base}/queue/touch`, {\n          method: \"POST\",\n\n          headers: self.headers,\n\n          body: JSON.stringify({ messageId }),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      hooks: {\n        create: async (runId: string, data: any) => {\n          const res = await fetch(`${base}/hooks`, {\n            method: \"POST\",\n\n            headers: self.headers,\n\n            body: JSON.stringify({ runId, ...data }),\n          });\n\n          if (!res.ok) throw new Error(await res.text());\n\n          return res.json();\n        },\n\n        get: async (id: string) => {\n          const res = await fetch(`${base}/hooks/${id}`, {\n            headers: self.headers,\n          });\n\n          if (!res.ok) throw new Error(await res.text());\n\n          return res.json();\n        },\n\n        getByToken: async (token: string) => {\n          const res = await fetch(`${base}/hooks?token=${token}`, {\n            headers: self.headers,\n          });\n\n          if (!res.ok) throw new Error(await res.text());\n\n          return res.json();\n        },\n\n        list: async (runId: string) => {\n          const res = await fetch(`${base}/hooks?runId=${runId}`, {\n            headers: self.headers,\n          });\n\n          if (!res.ok) throw new Error(await res.text());\n\n          return res.json();\n        },\n\n        dispose: async (id: string) => {\n          const res = await fetch(`${base}/hooks/${id}`, {\n            method: \"DELETE\",\n\n            headers: self.headers,\n          });\n\n          if (!res.ok) throw new Error(await res.text());\n\n          return res.json();\n        },\n      },\n    };\n  }\n\n  async gate(name: string, data?: any, options?: RequestInit) {\n    const fetchOptions: RequestInit = {\n      method: \"POST\",\n\n      ...options,\n\n      headers: {\n        ...this.headers,\n\n        ...(options?.headers || {}),\n      },\n    };\n\n    if (data) {\n      fetchOptions.body = JSON.stringify(data);\n    }\n\n    return await fetch(`${this.baseUrl}/api/gates/${name}`, fetchOptions);\n  }\n}\n", "export class WorkflowSuspension extends Error {\n  constructor(message: string = \"Workflow suspended\") {\n    super(message);\n    this.name = \"WorkflowSuspension\";\n  }\n}\n", "// Copyright (c) 2025 Anton A Nesterov <an+vski@vski.sh>, VSKI License\n//\n\nimport type { RocketBaseClient } from \"./client.ts\";\nimport { WorkflowSuspension } from \"./suspension.ts\";\n\nexport class WorkflowBase {\n  public client!: RocketBaseClient;\n  public runId: string = \"\";\n  public workflowName: string = \"unknown\";\n\n  public history = new Map<string, any>();\n  public completedSteps = new Set<string>();\n  public rollbackStack: string[] = [];\n  public stepAttempts = new Map<string, number>();\n\n  public callCounter = 0;\n  public signalQueues = new Map<string, any[]>();\n  public signalCursors = new Map<string, number>();\n  public isSuspended = false;\n\n  constructor(client?: RocketBaseClient) {\n    if (client) this.client = client;\n  }\n\n  async parallel<T>(steps: (() => Promise<T>)[]): Promise<T[]> {\n    return await Promise.all(steps.map((s) => s()));\n  }\n\n  public getDeterministicId(prefix: string) {\n    return `${prefix}-${this.callCounter++}`;\n  }\n\n  async sleep(duration: number | string): Promise<void> {\n    const id = this.getDeterministicId(\"sleep\");\n    if (this.completedSteps.has(id)) return;\n\n    if (!this.runId) {\n      throw new Error(\"Cannot sleep outside of a workflow context.\");\n    }\n\n    let ms = 0;\n    if (typeof duration === \"string\") {\n      if (duration.endsWith(\"s\")) {\n        ms = parseFloat(duration) * 1000;\n      } else if (duration.endsWith(\"m\")) {\n        ms = parseFloat(duration) * 60000;\n      } else if (duration.endsWith(\"ms\")) {\n        ms = parseFloat(duration);\n      } else {\n        // Default to ms if no suffix, or try parsing\n        ms = parseFloat(duration);\n        if (isNaN(ms)) throw new Error(`Invalid duration format: ${duration}`);\n      }\n    } else {\n      ms = duration;\n    }\n\n    const resumeAt = new Date(Date.now() + ms);\n\n    await this.client.workflow.createEvent(this.runId, {\n      eventType: \"wait_created\",\n      correlationId: id,\n      payload: { duration: ms, resumeAt: resumeAt.toISOString() },\n    });\n\n    this.isSuspended = true;\n    throw new WorkflowSuspension(`Sleeping for ${ms}ms`);\n  }\n\n  async waitForSignal<T = any>(name: string): Promise<T> {\n    const id = this.getDeterministicId(`signal-${name}`);\n    if (this.history.has(id)) {\n      const data = this.history.get(id) as T;\n      // Sync cursor if this strictly matched signal is also in the queue at current position\n      const queue = this.signalQueues.get(name);\n      if (queue) {\n        const cursor = this.signalCursors.get(name) || 0;\n        if (cursor < queue.length && queue[cursor] === data) {\n          this.signalCursors.set(name, cursor + 1);\n        }\n      }\n      return data;\n    }\n\n    const queue = this.signalQueues.get(name);\n    if (queue) {\n      const cursor = this.signalCursors.get(name) || 0;\n      if (cursor < queue.length) {\n        const data = queue[cursor];\n        this.signalCursors.set(name, cursor + 1);\n        return data as T;\n      }\n    }\n\n    if (!this.runId) {\n      throw new Error(\"Cannot wait for signal outside of a workflow context.\");\n    }\n\n    await this.client.workflow.createEvent(this.runId, {\n      eventType: \"signal_waiting\",\n      correlationId: id,\n      payload: { name },\n    });\n    this.isSuspended = true;\n    throw new WorkflowSuspension(`Waiting for signal: ${name}`);\n  }\n\n  async runRollback(error: any) {\n    const accumulator: Record<string, any> = {};\n    const stack = [...this.rollbackStack];\n    while (stack.length > 0) {\n      const method = stack.pop()!;\n      if (typeof (this as any)[method] === \"function\") {\n        try {\n          const result = await (this as any)[method](error, accumulator);\n          accumulator[method] = result;\n        } catch (e: any) {\n          if (e.name === \"StopRollback\") break;\n          console.error(`Rollback method ${method} failed:`, e.message);\n        }\n      }\n    }\n  }\n\n  rebuildState(events: any[]) {\n    this.history.clear();\n    this.completedSteps.clear();\n    this.rollbackStack = [];\n    this.stepAttempts.clear();\n    this.signalQueues.clear();\n    this.signalCursors.clear();\n    this.callCounter = 0;\n\n    for (const event of events) {\n      const payload = event.payload || {};\n      switch (event.eventType) {\n        case \"step_completed\":\n          this.completedSteps.add(event.correlationId);\n          this.history.set(event.correlationId, payload.output);\n          break;\n        case \"wait_completed\":\n          this.completedSteps.add(event.correlationId);\n          break;\n        case \"signal_received\":\n          this.history.set(event.correlationId, payload.data);\n          if (payload.name) {\n            if (!this.signalQueues.has(payload.name)) {\n              this.signalQueues.set(payload.name, []);\n            }\n            this.signalQueues.get(payload.name)!.push(payload.data);\n          }\n          break;\n        case \"rollback_registered\":\n          this.rollbackStack.push(payload.method);\n          break;\n        case \"step_retrying\":\n          this.stepAttempts.set(event.correlationId, payload.attempt);\n          break;\n      }\n    }\n  }\n\n  async executeStep(\n    id: string,\n    fn: (...args: any[]) => Promise<any>,\n    args: any[],\n    options: { retries?: number; rollback?: string[]; timeout?: string } = {},\n  ) {\n    if (!this.runId) return fn.apply(this, args);\n\n    if (this.completedSteps.has(id)) return this.history.get(id);\n\n    if (options.rollback) {\n      for (const method of options.rollback) {\n        const cid = `${id}-rb-${method}`;\n        if (!this.history.has(cid)) {\n          await this.client.workflow.createEvent(this.runId, {\n            eventType: \"rollback_registered\",\n            correlationId: cid,\n            payload: { method },\n          });\n          this.rollbackStack.push(method);\n        }\n      }\n    }\n\n    const maxRetries = options.retries || 0;\n    let attempt = 0;\n\n    // Initialize attempts if not present (from history reconstruction)\n    if (!this.stepAttempts.has(id)) {\n      this.stepAttempts.set(id, 0);\n    }\n    attempt = this.stepAttempts.get(id)!;\n\n    while (true) {\n      try {\n        await this.client.workflow.createEvent(this.runId, {\n          eventType: \"step_started\",\n          correlationId: id,\n          payload: { attempt },\n        });\n        const result = await fn.apply(this, args);\n        await this.client.workflow.createEvent(this.runId, {\n          eventType: \"step_completed\",\n          correlationId: id,\n          payload: { output: result },\n        });\n        this.completedSteps.add(id);\n        this.history.set(id, result);\n        return result;\n      } catch (e: any) {\n        if (attempt < maxRetries) {\n          attempt++;\n          this.stepAttempts.set(id, attempt);\n          await this.client.workflow.createEvent(this.runId, {\n            eventType: \"step_retrying\",\n            correlationId: id,\n            payload: { error: e.message, attempt },\n          });\n          await new Promise((r) => setTimeout(r, 1000 * attempt));\n          continue;\n        }\n        await this.client.workflow.createEvent(this.runId, {\n          eventType: \"step_failed\",\n          correlationId: id,\n          payload: { error: e.message, attempt },\n        });\n        throw e;\n      }\n    }\n  }\n}\n", "// Copyright (c) 2025 Anton A Nesterov <an+vski@vski.sh>, VSKI License\n//\n\nimport { WorkflowRegistry } from \"./registry.ts\";\nimport type { WorkflowBase } from \"./workflow-base.ts\";\nimport { WorkflowSuspension } from \"./suspension.ts\";\n\nexport function Workflow(\n  name: string,\n  options: { maxEvents?: number; executionTimeout?: number } = {},\n) {\n  return function (constructor: Function) {\n    WorkflowRegistry.set(name, constructor);\n    constructor.prototype.workflowName = name;\n    constructor.prototype.workflowOptions = options;\n\n    const originalRun = constructor.prototype.run;\n    if (originalRun) {\n      constructor.prototype.run = async function (...args: any[]) {\n        const self = this as WorkflowBase;\n        if (!self.client) throw new Error(\"Workflow needs a RocketBaseClient.\");\n\n        if (!self.runId) {\n          const run = await self.client.workflow.trigger(name, args, options);\n          self.runId = run.runId;\n        }\n\n        // Update status to running\n        await self.client.workflow.updateRun(self.runId, { status: \"running\" });\n\n        try {\n          const result = await originalRun.apply(self, args);\n          if (!self.isSuspended) {\n            await self.client.workflow.updateRun(self.runId, {\n              status: \"completed\",\n              output: result,\n            });\n          }\n          return result;\n        } catch (e: any) {\n          if (e instanceof WorkflowSuspension) {\n            // Workflow is suspended, just exit.\n            // Note: isSuspended is already true.\n            return;\n          }\n          console.error(`[Workflow ${name}] Failed:`, e.message);\n          try {\n            await self.runRollback(e);\n          } catch (re: any) {\n            console.error(`[Workflow ${name}] Rollback failed:`, re.message);\n          }\n          await self.client.workflow.updateRun(self.runId!, {\n            status: \"failed\",\n            error: { message: e.message, stack: e.stack },\n          });\n          throw e;\n        }\n      };\n    }\n  };\n}\n\nexport function Step(\n  id: string,\n  options: { retries?: number; rollback?: string[]; timeout?: string } = {},\n) {\n  return function (\n    _target: any,\n    _propertyKey: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    const originalMethod = descriptor.value;\n    descriptor.value = async function (...args: any[]) {\n      const self = this as WorkflowBase;\n      return self.executeStep(id, originalMethod, args, options);\n    };\n  };\n}\n", "// Copyright (c) 2025 Anton A Nesterov <an+vski@vski.sh>, VSKI License\n//\n\nimport { RocketBaseClient } from \"./client.ts\";\nimport { WorkflowRegistry } from \"./registry.ts\";\n\nexport class WorkflowWorker {\n  private socket: WebSocket | null = null;\n  private active = false;\n  private workflowName: string = \"\";\n  private stopCallback: (() => void) | null = null;\n  private activeJobs = new Set<Promise<void>>();\n\n  constructor(private client: RocketBaseClient) {}\n\n  async start(\n    workflowName: string,\n    options: { concurrency?: number; resume?: boolean } = {},\n  ): Promise<void> {\n    this.active = true;\n    this.workflowName = workflowName;\n    this.connect(workflowName);\n\n    if (options.resume) {\n      this.resumePending(workflowName).catch((e) =>\n        console.error(`[Worker ${workflowName}] Resume failed:`, e)\n      );\n    }\n\n    return new Promise((resolve) => {\n      this.stopCallback = resolve;\n    });\n  }\n\n  private async resumePending(workflowName: string) {\n    // Fetch runs that are not completed/failed\n    const pending = await this.client.workflow.listRuns({\n      workflowName,\n      status: \"pending\",\n    });\n    const running = await this.client.workflow.listRuns({\n      workflowName,\n      status: \"running\",\n    });\n\n    const all = [...pending.data, ...running.data];\n    console.log(`[Worker ${workflowName}] Resuming ${all.length} runs`);\n\n    for (const run of all) {\n      await this.client.workflow.resume(run.runId);\n    }\n  }\n\n  async stop() {\n    this.active = false;\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n\n    if (this.activeJobs.size > 0) {\n      console.log(\n        `[Worker ${this.workflowName}] Waiting for ${this.activeJobs.size} jobs to complete...`,\n      );\n      await Promise.allSettled(this.activeJobs);\n    }\n\n    if (this.stopCallback) {\n      this.stopCallback();\n      this.stopCallback = null;\n    }\n  }\n\n  private connect(workflowName: string) {\n    if (!this.active) return;\n\n    // Use ws:// for http:// and wss:// for https://\n    const token = this.client.getToken();\n    const wsUrl = this.client.baseUrl.replace(/^http/, \"ws\") +\n      \"/api/workflow/ws\" +\n      `?db=${this.client.dbName}` +\n      (token ? `&auth=${token}` : \"\");\n\n    this.socket = new WebSocket(wsUrl);\n\n    this.socket.onopen = () => {\n      console.log(`[Worker ${workflowName}] Connected to ${wsUrl}`);\n      this.socket?.send(JSON.stringify({\n        event: \"SUBSCRIBE\",\n        data: { queue: `__wkf_workflow_${workflowName}` },\n      }));\n    };\n\n    this.socket.onmessage = (event) => {\n      try {\n        const msg = JSON.parse(event.data);\n        if (msg.event === \"JOB\") {\n          const promise = this.processJob(msg.data);\n          this.activeJobs.add(promise);\n          promise.finally(() => this.activeJobs.delete(promise));\n        }\n      } catch (e) {\n        console.error(`[Worker ${workflowName}] Error handling message:`, e);\n      }\n    };\n\n    this.socket.onclose = () => {\n      if (this.active) {\n        console.log(`[Worker ${workflowName}] Disconnected, retrying...`);\n        setTimeout(() => this.connect(workflowName), 3000);\n      }\n    };\n\n    this.socket.onerror = (e) => {\n      console.error(`[Worker ${workflowName}] WebSocket error:`, e);\n    };\n  }\n\n  async processJob(job: any) {\n    console.log(`[Worker ${this.workflowName}] Processing job ${job.id}`);\n    const { runId, input } = job.data;\n\n    // Start heartbeat\n    const heartbeatInterval = setInterval(async () => {\n      try {\n        await this.client.workflow.touch(job.id);\n      } catch (e) {\n        console.warn(\n          `[Worker ${this.workflowName}] Heartbeat failed for job ${job.id}`,\n        );\n      }\n    }, 15000); // Every 15 seconds (well within the 30s timeout)\n\n    // The job.data should contain the inputs\n    // Check for correct workflow\n    if (job.data.workflowName && job.data.workflowName !== this.workflowName) {\n      console.warn(\n        `[Worker ${this.workflowName}] Received job for ${job.data.workflowName}, ignoring`,\n      );\n      clearInterval(heartbeatInterval);\n      await this.client.workflow.nack(job.id);\n      return;\n    }\n\n    try {\n      const [run, events] = await Promise.all([\n        this.client.workflow.getRun(runId),\n        this.client.workflow.listEvents(runId),\n      ]);\n\n      const Class = WorkflowRegistry.get(this.workflowName);\n      if (!Class) {\n        console.error(\n          `[Worker ${this.workflowName}] Workflow class not found in registry. Registered:`,\n          Array.from(WorkflowRegistry.keys()),\n        );\n        clearInterval(heartbeatInterval);\n        await this.client.workflow.nack(job.id);\n        return;\n      }\n\n      const instance = new Class(this.client);\n      instance.runId = runId;\n      instance.rebuildState(events);\n\n      // Execute with timeout\n      const timeout = run.executionTimeout || 30000;\n      let timeoutId: any;\n      const timeoutPromise = new Promise((_, reject) => {\n        timeoutId = setTimeout(\n          () => reject(new Error(\"CircuitBreaker: Execution timeout\")),\n          timeout,\n        );\n      });\n\n      try {\n        await Promise.race([\n          instance.run(...(input || [])),\n          timeoutPromise,\n        ]);\n      } finally {\n        clearTimeout(timeoutId);\n      }\n\n      // If we get here, execution completed successfully (or suspended successfully)\n      // Ack the job\n      clearInterval(heartbeatInterval);\n      await this.client.workflow.ack(job.id);\n      console.log(`[Worker ${this.workflowName}] Job ${job.id} completed`);\n    } catch (e: any) {\n      clearInterval(heartbeatInterval);\n      console.error(\n        `[Worker ${this.workflowName}] Job ${job.id} failed:`,\n        e.message,\n      );\n\n      if (e.message === \"CircuitBreaker: Execution timeout\") {\n        try {\n          await this.client.workflow.updateRun(runId, {\n            status: \"failed\",\n            error: { message: e.message },\n          });\n        } catch (err) {\n          console.error(\n            `[Worker ${this.workflowName}] Failed to update run status:`,\n            err,\n          );\n        }\n      }\n\n      // The workflow run status is already updated by the decorators to 'failed' if it bubbled up.\n      // We should ack the job because we processed it (and it failed),\n      // OR nack it if we want to retry?\n      // If the error was handled by decorators, instance.run might throw.\n      // If it throws, it means it failed.\n      // If we nack, it will retry.\n      // The Step decorator has retry logic. If it bubbles up, it means retries exhausted.\n      // So we should probably ACK it to stop retrying the WORKFLOW job, unless it was a transient system error.\n      // But for now, let's ACK it so we don't loop forever on a bug.\n      await this.client.workflow.ack(job.id);\n    }\n  }\n}\n", "// Copyright (c) 2025 Anton A Nesterov <an+vski@vski.sh>, VSKI License\n//\n\nexport class StopRollback extends Error {\n  constructor(message: string = \"Rollback stopped\") {\n    super(message);\n    this.name = \"StopRollback\";\n  }\n}\n", "// Copyright (c) 2025 Anton A Nesterov <an+vski@vski.sh>, VSKI License\n//\n\n// Runtime-agnostic context storage\n// In environments without AsyncLocalStorage (like browsers),\n// this uses a global variable which is NOT concurrency-safe for interleaved async calls.\n// For browser usage with multiple concurrent workflows, passing context explicitly or\n// using class-based workflows is recommended.\n\nlet currentContext: any = null;\n\nexport const WorkflowContext = {\n  run: <T>(ctx: any, fn: () => T): T => {\n    const prev = currentContext;\n    currentContext = ctx;\n    try {\n      const result = fn();\n      if (result instanceof Promise) {\n        return (result as any).finally(() => {\n          currentContext = prev;\n        });\n      }\n      currentContext = prev;\n      return result;\n    } catch (e) {\n      currentContext = prev;\n      throw e;\n    }\n  },\n  getStore: () => currentContext,\n};\n", "// Copyright (c) 2025 Anton A Nesterov <an+vski@vski.sh>, VSKI License\n//\n\nimport { WorkflowRegistry } from \"./registry.ts\";\nimport { WorkflowBase } from \"./workflow-base.ts\";\nimport { WorkflowContext as ContextManager } from \"./context.ts\";\nimport { WorkflowSuspension } from \"./suspension.ts\";\nimport type { WorkflowContext } from \"./types.ts\";\n\nexport function workflow(\n  name: string,\n  options: { maxEvents?: number; executionTimeout?: number } = {},\n) {\n  return {\n    run: (fn: (ctx: WorkflowContext, ...args: any[]) => Promise<any>) => {\n      // Create a dynamic class that extends WorkflowBase\n      const FunctionalWorkflow = class extends WorkflowBase {\n        static workflowName = name;\n        workflowName = name;\n        workflowOptions = options;\n\n        async run(...args: any[]) {\n          const self = this;\n          return await ContextManager.run(this, async () => {\n            try {\n              return await (fn as any).call(self, self, ...args);\n            } catch (e: any) {\n              throw e;\n            }\n          });\n        }\n      };\n\n      // Register context-aware wrapper similar to @Workflow decorator\n      WorkflowRegistry.set(name, FunctionalWorkflow);\n\n      // Monkey-patch prototype run to add the standard lifecycle logic\n      // (trigger check, status updates, rollback)\n      // This duplicates logic from @Workflow decorator. Ideally we extract it.\n      // But for now, let's implement it here.\n\n      const originalRun = FunctionalWorkflow.prototype.run;\n      FunctionalWorkflow.prototype.run = async function (...args: any[]) {\n        const self = this as WorkflowBase;\n        if (!self.client) throw new Error(\"Workflow needs a RocketBaseClient.\");\n\n        if (!self.runId) {\n          const run = await self.client.workflow.trigger(name, args, options);\n          self.runId = run.runId;\n        }\n\n        // Update status to running\n        await self.client.workflow.updateRun(self.runId, { status: \"running\" });\n\n        try {\n          const result = await (originalRun as any).apply(self, args);\n          if (!self.isSuspended) {\n            await self.client.workflow.updateRun(self.runId, {\n              status: \"completed\",\n              output: result,\n            });\n          }\n          return result;\n        } catch (e: any) {\n          if (e instanceof WorkflowSuspension) {\n            return;\n          }\n          console.error(`[Workflow ${name}] Failed:`, e.message);\n          try {\n            await self.runRollback(e);\n          } catch (re: any) {\n            console.error(`[Workflow ${name}] Rollback failed:`, re.message);\n          }\n          await self.client.workflow.updateRun(self.runId!, {\n            status: \"failed\",\n            error: { message: e.message, stack: e.stack },\n          });\n          throw e;\n        }\n      };\n\n      return FunctionalWorkflow;\n    },\n  };\n}\n\nexport function step(\n  idOrFn: string | ((...args: any[]) => Promise<any>),\n  fnOrOptions?: ((...args: any[]) => Promise<any>) | {\n    retries?: number;\n    rollback?: string[];\n    timeout?: string;\n  },\n  options?: { retries?: number; rollback?: string[]; timeout?: string },\n) {\n  let id: string;\n  let fn: (...args: any[]) => Promise<any>;\n  let opts: any = {};\n\n  if (typeof idOrFn === \"string\") {\n    id = idOrFn;\n    fn = fnOrOptions as any;\n    opts = options || {};\n  } else {\n    // Auto-generate ID if possible or require it?\n    // User example: const stepA = step(async () => {})\n    // We can't easily auto-generate stable IDs from anonymous functions without a build step.\n    // We'll require ID or use a random one (which breaks determinism on replay!).\n    // Ideally we require ID. But let's support the user example by assuming\n    // they might rely on execution order if we used a counter, but re-execution order must be deterministic.\n    // If the user assigns to a const, we don't know the const name.\n    // Let's THROW if no ID is provided for now to encourage best practice,\n    // OR generate one based on order if we had a global counter in context (but we define step OUTSIDE context).\n\n    // User example: `const stepA = step(async () => {})`\n    // This defines `stepA`.\n    // If we return a wrapper, when executed inside `run`, we can get the workflow instance.\n    // The instance has a call counter `getDeterministicId`. We can use that!\n\n    fn = idOrFn;\n    id = \"\"; // Will be generated at runtime\n    opts = fnOrOptions || {};\n  }\n\n  return async function (this: WorkflowContext | void, ...args: any[]) {\n    const context = (this instanceof WorkflowBase)\n      ? this as unknown as WorkflowBase\n      : ContextManager.getStore() as WorkflowBase;\n\n    if (!context) {\n      // If called outside of workflow context, just run the function\n      return await fn(...args);\n    }\n\n    // Generate ID if missing using the context's deterministic counter\n    const effectiveId = id || context.getDeterministicId(\"step\");\n\n    // We bind the function to the context so 'this' works inside the step implementation\n    return context.executeStep(effectiveId, fn.bind(context), args, opts);\n  };\n}\n"],
  "mappings": "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",
  "names": ["WorkflowRegistry", "RocketBaseClient", "baseUrl", "token", "key", "db", "h", "self", "res", "data", "name", "id", "email", "pass", "provider", "code", "redirectUrl", "identity", "password", "resData", "filters", "params", "value", "page", "perPage", "options", "q", "slug", "isFormData", "ids", "callback", "wsUrl", "sub", "event", "msg", "e", "err", "migrations", "applied", "appliedNames", "m", "mig", "base", "workflowName", "input", "mergedOptions", "WorkflowRegistry", "run", "runId", "p", "stepId", "queueName", "text", "signalName", "correlationId", "message", "opts", "messageId", "fetchOptions", "WorkflowSuspension", "message", "WorkflowBase", "client", "steps", "prefix", "duration", "id", "ms", "resumeAt", "WorkflowSuspension", "name", "data", "queue", "cursor", "error", "accumulator", "stack", "method", "result", "e", "events", "event", "payload", "fn", "args", "options", "cid", "maxRetries", "attempt", "r", "Workflow", "name", "options", "constructor", "WorkflowRegistry", "originalRun", "args", "self", "run", "result", "e", "WorkflowSuspension", "re", "Step", "id", "_target", "_propertyKey", "descriptor", "originalMethod", "WorkflowWorker", "client", "workflowName", "options", "e", "resolve", "pending", "running", "all", "run", "token", "wsUrl", "event", "msg", "promise", "job", "runId", "input", "heartbeatInterval", "events", "Class", "WorkflowRegistry", "instance", "timeout", "timeoutId", "timeoutPromise", "_", "reject", "err", "StopRollback", "message", "currentContext", "WorkflowContext", "ctx", "fn", "prev", "result", "e", "workflow", "name", "options", "fn", "FunctionalWorkflow", "WorkflowBase", "args", "self", "WorkflowContext", "e", "WorkflowRegistry", "originalRun", "run", "result", "WorkflowSuspension", "re", "step", "idOrFn", "fnOrOptions", "id", "opts", "context", "effectiveId"]
}
