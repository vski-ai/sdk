{
  "version": 3,
  "sources": ["../src/registry.ts", "../src/client.ts", "../src/suspension.ts", "../src/workflow-base.ts", "../src/decorators.ts", "../src/worker.ts", "../src/errors.ts", "../src/context.ts", "../src/functional.ts"],
  "sourcesContent": ["/**\n * Global registry for workflow classes and definitions.\n * Maps workflow names to their corresponding class constructors or implementations.\n */\nexport const WorkflowRegistry = new Map<string, any>();\n", "// Copyright (c) 2025 Anton A Nesterov <an+vski@vski.sh>, VSKI License\n//\n\nimport type {\n  AuthMethods,\n  AuthResponse,\n  CollectionConfig,\n  CronJob,\n  CronJobConfig,\n  DatabaseConfig,\n  Migration,\n  PaginatedList,\n  RealtimeEvent,\n  RecordData,\n  SubscriptionOptions,\n  WebhookLog,\n  WorkflowEvent,\n  WorkflowRun,\n  WorkflowStats,\n} from \"./types.ts\";\nimport { WorkflowRegistry } from \"./registry.ts\";\n\n/**\n * Main client for interacting with the RocketBase backend.\n * Provides access to databases, collections, authentication, workflows, and realtime features.\n */\nexport class RocketBaseClient {\n  /** The base URL of the RocketBase server. */\n  public baseUrl: string;\n  private token: string | null = null;\n  private apiKey: string | null = null;\n  /** The name of the database to use. */\n  public dbName: string = \"postgres\"; // Changed to public for Worker access\n  private adminDbName: string = \"postgres\";\n  private realtimeSocket: WebSocket | null = null;\n  private workflowSocket: WebSocket | null = null;\n  private subscriptions = new Map<\n    string,\n    {\n      callback: (e: RealtimeEvent) => void;\n      options?: SubscriptionOptions;\n    }\n  >();\n  private workflowSubscriptions = new Map<string, Set<(job: any) => void>>();\n\n  /**\n   * Creates a new instance of the RocketBase client.\n   * @param baseUrl - The base URL of the RocketBase server (default: http://127.0.0.1:3000).\n   */\n  constructor(baseUrl: string = \"http://127.0.0.1:3000\") {\n    this.baseUrl = baseUrl.endsWith(\"/\") ? baseUrl.slice(0, -1) : baseUrl;\n    if (typeof window !== \"undefined\") {\n      this.token = localStorage.getItem(\"pb_auth_token\");\n      this.apiKey = localStorage.getItem(\"rb_api_key\");\n    }\n  }\n\n  /**\n   * Retrieves the current authentication token.\n   * @returns The JWT token or null if not set.\n   */\n  getToken(): string | null {\n    return this.token;\n  }\n\n  /**\n   * Sets the authentication token.\n   * Updates the local storage and manages the realtime connection.\n   * @param token - The new JWT token or null to clear it.\n   */\n  setToken(token: string | null): void {\n    this.token = token;\n    if (typeof window !== \"undefined\") {\n      if (token) {\n        localStorage.setItem(\"pb_auth_token\", token);\n      } else {\n        localStorage.removeItem(\"pb_auth_token\");\n      }\n    }\n    if (this.realtimeSocket) {\n      this.realtimeSocket.close();\n    }\n  }\n\n  /**\n   * Sets the API key for backend-to-backend communication.\n   * @param key - The API key or null to clear it.\n   */\n  setApiKey(key: string | null): void {\n    this.apiKey = key;\n    if (typeof window !== \"undefined\") {\n      if (key) {\n        localStorage.setItem(\"rb_api_key\", key);\n      } else {\n        localStorage.removeItem(\"rb_api_key\");\n      }\n    }\n  }\n\n  /**\n   * Sets the target database for subsequent requests.\n   * @param db - The name of the database.\n   */\n  setDb(db: string): void {\n    this.dbName = db;\n    if (this.realtimeSocket) {\n      this.realtimeSocket.close();\n    }\n  }\n\n  /**\n   * Sets the target admin database for administrative requests.\n   * @param db - The name of the admin database (default: postgres).\n   */\n  setAdminDb(db: string): void {\n    this.adminDbName = db;\n    if (this.realtimeSocket) {\n      this.realtimeSocket.close();\n    }\n  }\n\n  /**\n   * Closes the client and terminates any active realtime connections.\n   */\n  close(): void {\n    if (this.realtimeSocket) {\n      this.realtimeSocket.onopen = null;\n      this.realtimeSocket.onmessage = null;\n      this.realtimeSocket.onerror = null;\n      this.realtimeSocket.onclose = null;\n      this.realtimeSocket.close();\n      this.realtimeSocket = null;\n    }\n    if (this.workflowSocket) {\n      this.workflowSocket.onopen = null;\n      this.workflowSocket.onmessage = null;\n      this.workflowSocket.onerror = null;\n      this.workflowSocket.onclose = null;\n      this.workflowSocket.close();\n      this.workflowSocket = null;\n    }\n    this.subscriptions.clear();\n    this.workflowSubscriptions.clear();\n  }\n\n  /**\n   * Subscribes a worker to jobs for a specific workflow.\n   * @param workflowName - The name of the workflow.\n   * @param callback - Function called when a job is received.\n   * @returns A function to unsubscribe.\n   */\n  subscribeWorkflow(\n    workflowName: string,\n    callback: (job: any) => void,\n  ): () => void {\n    if (!this.workflowSubscriptions.has(workflowName)) {\n      this.workflowSubscriptions.set(workflowName, new Set());\n    }\n    this.workflowSubscriptions.get(workflowName)!.add(callback);\n    this.connectWorkflow();\n\n    if (this.workflowSocket?.readyState === 1) {\n      this.workflowSocket.send(\n        JSON.stringify({\n          event: \"SUBSCRIBE\",\n          data: { queue: `__wkf_workflow_${workflowName}` },\n        }),\n      );\n    }\n\n    return () => {\n      const subs = this.workflowSubscriptions.get(workflowName);\n      if (subs) {\n        subs.delete(callback);\n        if (subs.size === 0) {\n          this.workflowSubscriptions.delete(workflowName);\n        }\n      }\n    };\n  }\n\n  /** Connects to the workflow WebSocket server. */\n  private connectWorkflow(): void {\n    if (typeof WebSocket === \"undefined\") return;\n    if (\n      this.workflowSocket &&\n      (this.workflowSocket.readyState === 0 ||\n        this.workflowSocket.readyState === 1)\n    ) {\n      return;\n    }\n\n    const token = this.getToken() || this.apiKey;\n    const wsUrl = this.baseUrl.replace(/^http/, \"ws\") +\n      \"/api/workflow/ws\" +\n      `?db=${this.dbName}` +\n      (token ? `&auth=${token}` : \"\");\n\n    this.workflowSocket = new WebSocket(wsUrl);\n\n    this.workflowSocket.onopen = () => {\n      this.workflowSubscriptions.forEach((_, name) => {\n        this.workflowSocket?.send(\n          JSON.stringify({\n            event: \"SUBSCRIBE\",\n            data: { queue: `__wkf_workflow_${name}` },\n          }),\n        );\n      });\n    };\n\n    this.workflowSocket.onmessage = (event) => {\n      try {\n        const msg = JSON.parse(event.data);\n        if (msg.event === \"JOB\") {\n          const workflowName = msg.data?.data?.workflowName;\n          if (!workflowName) return;\n\n          const subs = this.workflowSubscriptions.get(workflowName);\n          if (subs && subs.size > 0) {\n            // Load balance among local workers if multiple exist\n            const arr = Array.from(subs);\n            const listener = arr[Math.floor(Math.random() * arr.length)];\n            listener(msg.data);\n          }\n        }\n      } catch (e) {\n        console.error(\"Error handling workflow message:\", e);\n      }\n    };\n\n    this.workflowSocket.onclose = () => {\n      if (this.workflowSubscriptions.size > 0) {\n        setTimeout(() => this.connectWorkflow(), 3000);\n      }\n    };\n  }\n\n  /** Headers for standard requests. */\n  private get headers(): Record<string, string> {\n    const h: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"x-dbname\": this.dbName,\n    };\n    if (this.token) h[\"Authorization\"] = `Bearer ${this.token}`;\n    if (this.apiKey) h[\"X-API-Key\"] = this.apiKey;\n    return h;\n  }\n\n  /** Headers for administrative requests. */\n  private get adminHeaders(): Record<string, string> {\n    const h: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"x-dbname\": this.adminDbName,\n    };\n    if (this.token) h[\"Authorization\"] = `Bearer ${this.token}`;\n    if (this.apiKey) h[\"X-API-Key\"] = this.apiKey;\n    return h;\n  }\n\n  /**\n   * Namespace for system settings and configuration (Databases, Collections).\n   * @returns An object with database and collection management methods.\n   */\n  get settings(): {\n    databases: {\n      list: () => Promise<string[]>;\n      create: (data: DatabaseConfig) => Promise<unknown>;\n      delete: (name: string) => Promise<boolean>;\n    };\n    collections: {\n      create: (data: CollectionConfig) => Promise<unknown>;\n      update: (id: string, data: Partial<CollectionConfig>) => Promise<unknown>;\n      delete: (id: string) => Promise<boolean>;\n      getList: () => Promise<PaginatedList<CollectionConfig>>;\n    };\n  } {\n    // @ts-ignore:\n    const self = this;\n    return {\n      /**\n       * Database management operations.\n       */\n      databases: {\n        /**\n         * Lists all available databases.\n         */\n        list: async (): Promise<string[]> => {\n          const res = await fetch(`${self.baseUrl}/api/databases`, {\n            headers: self.headers,\n          });\n          if (!res.ok) throw new Error(await res.text());\n          return res.json();\n        },\n        /**\n         * Creates a new database.\n         * @param data - Configuration for the new database.\n         */\n        create: async (data: DatabaseConfig): Promise<unknown> => {\n          const res = await fetch(`${self.baseUrl}/api/databases`, {\n            method: \"POST\",\n            headers: self.headers,\n            body: JSON.stringify(data),\n          });\n          if (!res.ok) throw new Error(await res.text());\n          return res.json();\n        },\n        /**\n         * Deletes a database by name.\n         * @param name - The name of the database to delete.\n         */\n        delete: async (name: string): Promise<boolean> => {\n          const res = await fetch(`${self.baseUrl}/api/databases/${name}`, {\n            method: \"DELETE\",\n            headers: self.headers,\n          });\n          if (!res.ok) throw new Error(await res.text());\n          await res.text();\n          return true;\n        },\n      },\n      /**\n       * Collection management operations.\n       */\n      collections: {\n        /**\n         * Creates a new collection.\n         * @param data - The collection schema definition.\n         */\n        create: async (data: CollectionConfig): Promise<unknown> => {\n          const res = await fetch(`${self.baseUrl}/api/collections`, {\n            method: \"POST\",\n            headers: self.headers,\n            body: JSON.stringify(data),\n          });\n          if (!res.ok) throw new Error(await res.text());\n          return res.json();\n        },\n        /**\n         * Updates an existing collection.\n         * @param id - The ID or name of the collection.\n         * @param data - The fields to update.\n         */\n        update: async (\n          id: string,\n          data: Partial<CollectionConfig>,\n        ): Promise<unknown> => {\n          const res = await fetch(`${self.baseUrl}/api/collections/${id}`, {\n            method: \"PATCH\",\n            headers: self.headers,\n            body: JSON.stringify(data),\n          });\n          if (!res.ok) throw new Error(await res.text());\n          return res.json();\n        },\n        /**\n         * Deletes a collection.\n         * @param id - The ID or name of the collection.\n         */\n        delete: async (id: string): Promise<boolean> => {\n          const res = await fetch(`${self.baseUrl}/api/collections/${id}`, {\n            method: \"DELETE\",\n            headers: self.headers,\n          });\n          if (!res.ok) throw new Error(await res.text());\n          await res.text();\n          return true;\n        },\n        /**\n         * Lists all collections.\n         */\n        getList: async (): Promise<PaginatedList<CollectionConfig>> => {\n          const res = await fetch(`${self.baseUrl}/api/collections`, {\n            headers: self.headers,\n          });\n          if (!res.ok) throw new Error(await res.text());\n          return res.json();\n        },\n      },\n    };\n  }\n\n  /**\n   * Namespace for authentication operations (Login, Register, OAuth).\n   * @returns An object with authentication methods.\n   */\n  get auth(): {\n    login: (email: string, pass: string) => Promise<AuthResponse>;\n    register: (data: RecordData) => Promise<unknown>;\n    me: () => Promise<RecordData>;\n    listMethods: () => Promise<AuthMethods>;\n    authViaOAuth2: (\n      provider: string,\n      code: string,\n      redirectUrl: string,\n    ) => Promise<AuthResponse>;\n  } {\n    const self = this;\n    return {\n      /**\n       * Login using the configured default auth collection.\n       * @param email - The user's email.\n       * @param pass - The user's password.\n       */\n      login: async (email: string, pass: string): Promise<AuthResponse> => {\n        const res = await fetch(`${self.baseUrl}/api/auth/login`, {\n          method: \"POST\",\n          headers: self.headers,\n          body: JSON.stringify({ identity: email, password: pass }),\n        });\n        if (!res.ok) throw new Error(await res.text());\n        const data = await res.json();\n        self.setToken(data.token);\n        return data;\n      },\n      /**\n       * Register a new user in the configured default auth collection.\n       * @param data - The user registration data.\n       */\n      register: async (data: RecordData): Promise<unknown> => {\n        const res = await fetch(`${self.baseUrl}/api/auth/register`, {\n          method: \"POST\",\n          headers: self.headers,\n          body: JSON.stringify(data),\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n      /**\n       * Get the profile of the currently logged in user.\n       */\n      me: async (): Promise<RecordData> => {\n        const res = await fetch(`${self.baseUrl}/api/auth/me`, {\n          headers: self.headers,\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n      /**\n       * List available auth methods (OAuth providers).\n       */\n      listMethods: async (): Promise<AuthMethods> => {\n        const res = await fetch(`${self.baseUrl}/api/auth/methods`, {\n          headers: self.headers,\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n      /**\n       * Login via OAuth2 code.\n       * @param provider - The OAuth2 provider name (e.g., 'google', 'github').\n       * @param code - The authorization code returned by the provider.\n       * @param redirectUrl - The redirect URL used in the initial auth request.\n       */\n      authViaOAuth2: async (\n        provider: string,\n        code: string,\n        redirectUrl: string,\n      ): Promise<AuthResponse> => {\n        const res = await fetch(`${self.baseUrl}/api/auth/oauth2-login`, {\n          method: \"POST\",\n          headers: self.headers,\n          body: JSON.stringify({ provider, code, redirectUrl }),\n        });\n        if (!res.ok) throw new Error(await res.text());\n        const data = await res.json();\n        self.setToken(data.token);\n        return data;\n      },\n    };\n  }\n\n  /**\n   * Namespace for API key management.\n   * @returns An object with API key management methods.\n   */\n  get keys(): {\n    generate: (data: {\n      name?: string;\n      enabled?: boolean;\n    }) => Promise<unknown>;\n  } {\n    const self = this;\n    return {\n      /**\n       * Generates a new API key.\n       * @param data - Configuration for the new key.\n       */\n      generate: async (data: {\n        name?: string;\n        enabled?: boolean;\n      }): Promise<unknown> => {\n        const res = await fetch(`${self.baseUrl}/api/keys`, {\n          method: \"POST\",\n          headers: self.adminHeaders,\n          body: JSON.stringify(data),\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n    };\n  }\n\n  /**\n   * Namespace for admin-level operations.\n   * @returns An object with administrative methods.\n   */\n  get admins(): {\n    authWithPassword: (\n      identity: string,\n      password: string,\n    ) => Promise<AuthResponse>;\n    init: (data: { email: string; password: string }) => Promise<unknown>;\n    hasAdmins: () => Promise<{ hasAdmins: boolean }>;\n    me: () => Promise<RecordData>;\n  } {\n    const self = this;\n    return {\n      /**\n       * Authenticates an admin user with email and password.\n       * @param identity - Admin email.\n       * @param password - Admin password.\n       */\n      authWithPassword: async (\n        identity: string,\n        password: string,\n      ): Promise<AuthResponse> => {\n        const res = await fetch(\n          `${self.baseUrl}/api/admins/auth-with-password`,\n          {\n            method: \"POST\",\n            headers: self.headers,\n            body: JSON.stringify({ identity, password }),\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        const data = await res.json();\n        self.setToken(data.token);\n        return data;\n      },\n      /**\n       * Initializes the first admin account.\n       * @param data - Admin registration data.\n       */\n      init: async (data: {\n        email: string;\n        password: string;\n      }): Promise<unknown> => {\n        const res = await fetch(`${self.baseUrl}/api/admins/init`, {\n          method: \"POST\",\n          headers: self.headers,\n          body: JSON.stringify(data),\n        });\n        if (!res.ok) throw new Error(await res.text());\n        const resData = await res.json();\n        self.setToken(resData.token);\n        return resData;\n      },\n      /**\n       * Checks if any admin accounts exist.\n       * @returns Object containing a boolean `hasAdmins`.\n       */\n      hasAdmins: async (): Promise<{ hasAdmins: boolean }> => {\n        const res = await fetch(`${self.baseUrl}/api/admins/has-admins`, {\n          headers: self.headers,\n        });\n        if (!res.ok) {\n          await res.text();\n          return { hasAdmins: false };\n        }\n        return res.json();\n      },\n      /**\n       * Gets the currently authenticated admin's profile.\n       */\n      me: async (): Promise<RecordData> => {\n        const res = await fetch(`${self.baseUrl}/api/admins/me`, {\n          headers: self.adminHeaders,\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n    };\n  }\n\n  /**\n   * Namespace for Cron job management.\n   * @returns An object with cron job management methods.\n   */\n  get cron(): {\n    list: () => Promise<CronJob[]>;\n    create: (data: CronJobConfig) => Promise<unknown>;\n    delete: (name: string) => Promise<boolean>;\n  } {\n    const self = this;\n    return {\n      /**\n       * Lists all registered cron jobs.\n       */\n      list: async (): Promise<CronJob[]> => {\n        const res = await fetch(`${self.baseUrl}/api/cron`, {\n          headers: self.headers,\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n      /**\n       * Registers a new cron job.\n       * @param data - Cron job configuration (schedule, endpoint, etc.).\n       */\n      create: async (data: CronJobConfig): Promise<unknown> => {\n        const res = await fetch(`${self.baseUrl}/api/cron`, {\n          method: \"POST\",\n          headers: self.headers,\n          body: JSON.stringify(data),\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n      /**\n       * Deletes a cron job by name.\n       * @param name - The name of the cron job to delete.\n       */\n      delete: async (name: string): Promise<boolean> => {\n        const res = await fetch(`${self.baseUrl}/api/cron/${name}`, {\n          method: \"DELETE\",\n          headers: self.headers,\n        });\n        if (!res.ok) throw new Error(await res.text());\n        await res.text();\n        return true;\n      },\n    };\n  }\n\n  /**\n   * Namespace for Webhook logs.\n   * @returns An object with webhook log access methods.\n   */\n  get webhookLogs(): {\n    list: (filters?: {\n      collection?: string;\n      status?: string;\n      page?: number;\n      perPage?: number;\n    }) => Promise<PaginatedList<WebhookLog>>;\n  } {\n    const self = this;\n    return {\n      /**\n       * Lists webhook execution logs with optional filtering.\n       * @param filters - Options to filter logs by collection, status, page, etc.\n       */\n      list: async (\n        filters: {\n          collection?: string;\n          status?: string;\n          page?: number;\n          perPage?: number;\n        } = {},\n      ): Promise<PaginatedList<WebhookLog>> => {\n        const params = new URLSearchParams();\n        Object.entries(filters).forEach(([key, value]) => {\n          if (value !== undefined && value !== \"\") {\n            params.append(key, value.toString());\n          }\n        });\n        const res = await fetch(\n          `${self.baseUrl}/api/webhooks/logs?${params.toString()}`,\n          {\n            headers: self.headers,\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n    };\n  }\n\n  /**\n   * Namespace for Workflow statistics.\n   * @returns An object with workflow statistics methods.\n   */\n  get workflowStats(): {\n    get: () => Promise<WorkflowStats>;\n  } {\n    const self = this;\n    return {\n      /**\n       * Retrieves aggregated statistics about workflow executions.\n       */\n      get: async (): Promise<WorkflowStats> => {\n        const res = await fetch(`${self.baseUrl}/api/workflows/stats`, {\n          headers: self.headers,\n        });\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n    };\n  }\n\n  /**\n   * Returns a handler for a specific collection.\n   * Provides methods for record CRUD, search, and realtime subscriptions.\n   * @param name - The name of the collection.\n   * @returns A collection handler object.\n   */\n  collection<T = RecordData>(name: string): {\n    getList: (\n      page?: number,\n      perPage?: number,\n      options?: { filter?: string; expand?: string; sort?: string },\n    ) => Promise<PaginatedList<T>>;\n    getOne: (id: string, options?: { expand?: string }) => Promise<T>;\n    search: (\n      q: string,\n      options?: {\n        page?: number;\n        perPage?: number;\n        expand?: string;\n        snippet?: boolean;\n      },\n    ) => Promise<PaginatedList<T>>;\n    getView: (\n      slug: string,\n      options?: {\n        page?: number;\n        perPage?: number;\n        expand?: string;\n        filter?: string;\n        sort?: string;\n      },\n    ) => Promise<PaginatedList<T>>;\n    create: (data: RecordData | FormData | Partial<T>) => Promise<T>;\n    update: (\n      id: string,\n      data: RecordData | FormData | Partial<T>,\n    ) => Promise<T>;\n    bulkUpdate: (\n      ids: string[],\n      data: RecordData | Partial<T>,\n    ) => Promise<{ updated: string[] }>;\n    delete: (id: string) => Promise<boolean>;\n    bulkDelete: (ids: string[]) => Promise<{ deleted: string[] }>;\n    authWithPassword: (\n      identity: string,\n      password: string,\n    ) => Promise<AuthResponse>;\n    subscribe: (\n      callback: (e: RealtimeEvent<T>) => void,\n      options?: SubscriptionOptions,\n    ) => () => void;\n  } {\n    const self = this;\n\n    return {\n      /**\n       * Lists records in the collection with pagination and filtering.\n       * @param page - The page number (default: 1).\n       * @param perPage - Records per page (default: 30).\n       * @param options - Additional options like filter and expand.\n       */\n      getList: async (\n        page = 1,\n        perPage = 30,\n        options: { filter?: string; expand?: string; sort?: string } = {},\n      ): Promise<PaginatedList<T>> => {\n        const params = new URLSearchParams({\n          page: String(page),\n          perPage: String(perPage),\n        });\n        if (options.filter) params.append(\"filter\", options.filter);\n        if (options.expand) params.append(\"expand\", options.expand);\n        if (options.sort) params.append(\"sort\", options.sort);\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records?${params.toString()}`,\n          { headers: self.headers },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      /**\n       * Retrieves a single record by ID.\n       * @param id - The record ID.\n       * @param options - Options like expand.\n       */\n      getOne: async (\n        id: string,\n        options: { expand?: string } = {},\n      ): Promise<T> => {\n        const params = new URLSearchParams();\n        if (options.expand) params.append(\"expand\", options.expand);\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/${id}?${params.toString()}`,\n          { headers: self.headers },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      /**\n       * Searches for records using a full-text query.\n       * @param q - The search query.\n       * @param options - Pagination and expansion options.\n       */\n      search: async (\n        q: string,\n        options: {\n          page?: number;\n          perPage?: number;\n          expand?: string;\n          snippet?: boolean;\n        } = {},\n      ): Promise<PaginatedList<T>> => {\n        const params = new URLSearchParams({ q });\n        if (options.page) params.append(\"page\", String(options.page));\n        if (options.perPage) params.append(\"perPage\", String(options.perPage));\n        if (options.expand) params.append(\"expand\", options.expand);\n        if (options.snippet) params.append(\"snippet\", \"true\");\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/search?${params.toString()}`,\n          { headers: self.headers },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      /**\n       * Retrieves records from a specific view.\n       * @param slug - The view slug.\n       * @param options - Pagination, filter, and sort options.\n       */\n      getView: async (\n        slug: string,\n        options: {\n          page?: number;\n          perPage?: number;\n          expand?: string;\n          filter?: string;\n          sort?: string;\n        } = {},\n      ): Promise<PaginatedList<T>> => {\n        const params = new URLSearchParams();\n        if (options.page) params.append(\"page\", String(options.page));\n        if (options.perPage) params.append(\"perPage\", String(options.perPage));\n        if (options.expand) params.append(\"expand\", options.expand);\n        if (options.filter) params.append(\"filter\", options.filter);\n        if (options.sort) params.append(\"sort\", options.sort);\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/views/${slug}?${params.toString()}`,\n          { headers: self.headers },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      /**\n       * Creates a new record in the collection.\n       * @param data - The record data.\n       */\n      create: async (\n        data: RecordData | FormData | Partial<T>,\n      ): Promise<T> => {\n        const isFormData = data instanceof FormData;\n        const h = { ...self.headers };\n        if (isFormData) delete h[\"Content-Type\"];\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records`,\n          {\n            method: \"POST\",\n            headers: h,\n            body: isFormData ? data : JSON.stringify(data),\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      /**\n       * Updates an existing record.\n       * @param id - The record ID.\n       * @param data - The data to update.\n       */\n      update: async (\n        id: string,\n        data: RecordData | FormData | Partial<T>,\n      ): Promise<T> => {\n        const isFormData = data instanceof FormData;\n        const h = { ...self.headers };\n        if (isFormData) delete h[\"Content-Type\"];\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/${id}`,\n          {\n            method: \"PATCH\",\n            headers: h,\n            body: isFormData ? data : JSON.stringify(data),\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      /**\n       * Bulk updates multiple records.\n       * @param ids - The IDs of the records to update.\n       * @param data - The data to apply to all records.\n       */\n      bulkUpdate: async (\n        ids: string[],\n        data: RecordData | Partial<T>,\n      ): Promise<{ updated: string[] }> => {\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/bulk`,\n          {\n            method: \"PATCH\",\n            headers: self.headers,\n            body: JSON.stringify({ ids, data }),\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      /**\n       * Deletes a record.\n       * @param id - The record ID.\n       */\n      delete: async (id: string): Promise<boolean> => {\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/${id}`,\n          {\n            method: \"DELETE\",\n            headers: self.headers,\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        await res.text();\n        return true;\n      },\n\n      /**\n       * Bulk deletes multiple records.\n       * @param ids - The IDs of the records to delete.\n       */\n      bulkDelete: async (ids: string[]): Promise<{ deleted: string[] }> => {\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/bulk`,\n          {\n            method: \"DELETE\",\n            headers: self.headers,\n            body: JSON.stringify({ ids }),\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n\n      /**\n       * Authenticates a user of this collection (e.g., 'users' collection) using a password.\n       * @param identity - The user identity (e.g., username or email).\n       * @param password - The user password.\n       */\n      authWithPassword: async (\n        identity: string,\n        password: string,\n      ): Promise<AuthResponse> => {\n        if (name === \"_superusers\") {\n          return self.admins.authWithPassword(identity, password);\n        }\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/auth-with-password`,\n          {\n            method: \"POST\",\n            headers: self.headers,\n            body: JSON.stringify({ identity, password }),\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        const data = await res.json();\n        self.setToken(data.token);\n        return data;\n      },\n\n      /**\n       * Subscribes to realtime changes in the collection.\n       * @param callback - Function called when an event occurs.\n       * @param options - Subscription options (filter, etc.).\n       * @returns A function to unsubscribe.\n       */\n      subscribe: (\n        callback: (e: RealtimeEvent<T>) => void,\n        options?: SubscriptionOptions,\n      ): () => void => {\n        self.subscriptions.set(name, { callback: callback as any, options });\n        self.connectRealtime();\n\n        if (self.realtimeSocket?.readyState === 1) {\n          self.realtimeSocket.send(\n            JSON.stringify({ type: \"SUBSCRIBE\", collection: name, ...options }),\n          );\n        }\n\n        return () => {\n          self.subscriptions.delete(name);\n        };\n      },\n    };\n  }\n\n  /** Connects to the realtime WebSocket server. */\n  private connectRealtime(): void {\n    if (typeof WebSocket === \"undefined\") return;\n    if (\n      this.realtimeSocket &&\n      (this.realtimeSocket.readyState === 0 ||\n        this.realtimeSocket.readyState === 1)\n    ) {\n      return;\n    }\n\n    const wsUrl = this.baseUrl.replace(\"http\", \"ws\") +\n      \"/api/realtime\" +\n      `?db=${this.dbName}` +\n      (this.token ? `&auth=${this.token}` : \"\");\n    this.realtimeSocket = new WebSocket(wsUrl);\n\n    this.realtimeSocket.onopen = () => {\n      this.subscriptions.forEach((sub, name) => {\n        this.realtimeSocket?.send(\n          JSON.stringify({\n            type: \"SUBSCRIBE\",\n            collection: name,\n            ...sub.options,\n          }),\n        );\n      });\n    };\n\n    this.realtimeSocket.onmessage = (event) => {\n      const msg = JSON.parse(event.data);\n      const sub = this.subscriptions.get(msg.collection);\n      if (!sub || !msg.events) return;\n\n      msg.events.forEach((e: any) => {\n        try {\n          sub.callback(e.data);\n          if (!sub.options?.group) {\n            sub.options = { ...sub.options, lastId: e.id };\n          }\n          if (e.ackId && sub.options?.group) {\n            this.realtimeSocket?.send(\n              JSON.stringify({\n                type: \"ACK\",\n                collection: msg.collection,\n                id: e.ackId,\n                group: sub.options.group,\n              }),\n            );\n          }\n        } catch (err) {\n          console.error(\"Error handling realtime event:\", err);\n        }\n      });\n    };\n\n    this.realtimeSocket.onclose = () => {\n      if (this.subscriptions.size > 0) {\n        setTimeout(() => this.connectRealtime(), 3000);\n      }\n    };\n  }\n\n  /**\n   * Namespace for database migrations.\n   * @returns An object with migration methods.\n   */\n  get migrations(): {\n    getList: (\n      page?: number,\n      perPage?: number,\n      options?: { filter?: string; sort?: string },\n    ) => Promise<PaginatedList<Migration>>;\n    create: (data: {\n      name: string;\n      appliedAt: string;\n      batch?: number;\n    }) => Promise<Migration>;\n    delete: (id: string) => Promise<boolean>;\n    run: (\n      migrations: {\n        name: string;\n        up: (sdk: RocketBaseClient) => Promise<void>;\n      }[],\n    ) => Promise<void>;\n  } {\n    const self = this;\n    const name = \"_migrations\";\n    return {\n      /**\n       * Lists applied migrations.\n       */\n      getList: async (\n        page = 1,\n        perPage = 500,\n        options: { filter?: string; sort?: string } = {},\n      ): Promise<PaginatedList<Migration>> => {\n        const params = new URLSearchParams({\n          page: String(page),\n          perPage: String(perPage),\n        });\n        if (options.filter) params.append(\"filter\", options.filter);\n        if (options.sort) params.append(\"sort\", options.sort);\n\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records?${params.toString()}`,\n          { headers: self.adminHeaders },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n      /**\n       * Creates a migration record.\n       */\n      create: async (data: {\n        name: string;\n        appliedAt: string;\n        batch?: number;\n      }): Promise<Migration> => {\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records`,\n          {\n            method: \"POST\",\n            headers: self.adminHeaders,\n            body: JSON.stringify(data),\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        return res.json();\n      },\n      /**\n       * Deletes a migration record.\n       */\n      delete: async (id: string): Promise<boolean> => {\n        const res = await fetch(\n          `${self.baseUrl}/api/collections/${name}/records/${id}`,\n          {\n            method: \"DELETE\",\n            headers: self.adminHeaders,\n          },\n        );\n        if (!res.ok) throw new Error(await res.text());\n        await res.text();\n        return true;\n      },\n      /**\n       * Runs a list of pending migrations.\n       * @param migrations - List of migration objects with `up` functions.\n       */\n      run: async (\n        migrations: {\n          name: string;\n          up: (sdk: RocketBaseClient) => Promise<void>;\n        }[],\n      ): Promise<void> => {\n        const applied = await self.migrations.getList(1, 500);\n        const appliedNames = new Set(applied.items.map((m: any) => m.name));\n\n        for (const mig of migrations) {\n          if (!appliedNames.has(mig.name)) {\n            console.log(`[Migrations] Applying: ${mig.name}`);\n            await mig.up(self);\n            await self.migrations.create({\n              name: mig.name,\n              appliedAt: new Date().toISOString(),\n              batch: 1, // For now\n            });\n          }\n        }\n      },\n    };\n  }\n\n  /**\n   * Namespace for Workflow operations (Runs, Events, Signals, Queues).\n   * @returns An object with workflow management methods.\n   */\n  get workflow(): {\n    createRun: (data: Partial<WorkflowRun>) => Promise<WorkflowRun>;\n    trigger: (\n      workflowName: string,\n      input: unknown[],\n      options?: any,\n    ) => Promise<WorkflowRun>;\n    resume: (runId: string) => Promise<WorkflowRun>;\n    getRun: (runId: string) => Promise<WorkflowRun>;\n    updateRun: (\n      runId: string,\n      data: Partial<WorkflowRun>,\n    ) => Promise<WorkflowRun>;\n    listRuns: (params?: {\n      workflowName?: string;\n      status?: string;\n      limit?: number;\n      cursor?: string;\n    }) => Promise<PaginatedList<WorkflowRun>>;\n    createStep: (runId: string, data: any) => Promise<unknown>;\n    updateStep: (runId: string, stepId: string, data: any) => Promise<unknown>;\n    createEvent: (\n      runId: string,\n      data: {\n        eventType: string;\n        correlationId?: string;\n        payload: Record<string, unknown>;\n      },\n    ) => Promise<WorkflowEvent>;\n    listEvents: (runId: string) => Promise<WorkflowEvent[]>;\n    pollQueue: (queueName: string) => Promise<unknown>;\n    sendSignal: (\n      runId: string,\n      signalName: string,\n      data: any,\n      correlationId?: string,\n    ) => Promise<boolean>;\n    queueMessage: (\n      queueName: string,\n      message: any,\n      opts?: any,\n    ) => Promise<unknown>;\n    ack: (messageId: string) => Promise<unknown>;\n    nack: (messageId: string) => Promise<unknown>;\n    touch: (messageId: string) => Promise<unknown>;\n    hooks: {\n      create: (runId: string, data: any) => Promise<unknown>;\n      get: (id: string) => Promise<unknown>;\n      getByToken: (token: string) => Promise<unknown>;\n      list: (runId: string) => Promise<unknown>;\n      dispose: (id: string) => Promise<unknown>;\n    };\n  } {\n    const self = this;\n\n    const base = `${self.baseUrl}/api/workflows`;\n\n    return {\n      /**\n       * Creates a new workflow run directly.\n       */\n      createRun: async (data: Partial<WorkflowRun>): Promise<WorkflowRun> => {\n        const res = await fetch(`${base}/runs`, {\n          method: \"POST\",\n\n          headers: self.headers,\n\n          body: JSON.stringify(data),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      /**\n       * Triggers a workflow execution.\n       * @param workflowName - Name of the workflow.\n       * @param input - Input arguments.\n       * @param options - Execution options.\n       */\n      trigger: async (\n        workflowName: string,\n        input: unknown[],\n        options: any = {},\n      ): Promise<WorkflowRun> => {\n        const Class = WorkflowRegistry.get(workflowName);\n        const defaultOptions = Class?.prototype?.workflowOptions || {};\n        const mergedOptions = { ...defaultOptions, ...options };\n\n        const run = await self.workflow.createRun({\n          deploymentId: mergedOptions.deploymentId || \"sdk\",\n\n          workflowName,\n\n          input,\n          ...mergedOptions,\n        });\n\n        await self.workflow.queueMessage(`__wkf_workflow_${workflowName}`, {\n          type: \"workflow_start\",\n\n          runId: run.runId,\n\n          workflowName,\n\n          input,\n        });\n\n        return run;\n      },\n\n      /**\n       * Resumes a suspended workflow run.\n       * @param runId - The run ID.\n       */\n      resume: async (runId: string): Promise<WorkflowRun> => {\n        const run = await self.workflow.getRun(runId);\n\n        await self.workflow.queueMessage(`__wkf_workflow_${run.workflowName}`, {\n          type: \"resume\",\n\n          runId: run.runId,\n\n          workflowName: run.workflowName,\n\n          input: run.input,\n        });\n\n        return run;\n      },\n\n      /**\n       * Retrieves a workflow run by ID.\n       */\n      getRun: async (runId: string): Promise<WorkflowRun> => {\n        const res = await fetch(`${base}/runs/${runId}`, {\n          headers: self.headers,\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      /**\n       * Updates a workflow run.\n       */\n      updateRun: async (\n        runId: string,\n        data: Partial<WorkflowRun>,\n      ): Promise<WorkflowRun> => {\n        const res = await fetch(`${base}/runs/${runId}`, {\n          method: \"PATCH\",\n\n          headers: self.headers,\n\n          body: JSON.stringify(data),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      /**\n       * Lists workflow runs.\n       */\n      listRuns: async (\n        params: {\n          workflowName?: string;\n\n          status?: string;\n\n          limit?: number;\n\n          cursor?: string;\n        } = {},\n      ): Promise<PaginatedList<WorkflowRun>> => {\n        const p = new URLSearchParams();\n\n        if (params.workflowName) p.append(\"workflowName\", params.workflowName);\n\n        if (params.status) p.append(\"status\", params.status);\n\n        if (params.limit) p.append(\"limit\", String(params.limit));\n\n        if (params.cursor) p.append(\"cursor\", params.cursor);\n\n        const res = await fetch(`${base}/runs?${p.toString()}`, {\n          headers: self.headers,\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      /**\n       * Records a new workflow step.\n       */\n      createStep: async (runId: string, data: any): Promise<unknown> => {\n        const res = await fetch(`${base}/steps`, {\n          method: \"POST\",\n\n          headers: self.headers,\n\n          body: JSON.stringify({ runId, ...data }),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      /**\n       * Updates a workflow step.\n       */\n      updateStep: async (\n        runId: string,\n        stepId: string,\n        data: any,\n      ): Promise<unknown> => {\n        const res = await fetch(`${base}/steps/${runId}/${stepId}`, {\n          method: \"PATCH\",\n\n          headers: self.headers,\n\n          body: JSON.stringify(data),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      /**\n       * Creates a workflow event.\n       */\n      createEvent: async (\n        runId: string,\n        data: {\n          eventType: string;\n          correlationId?: string;\n          payload: Record<string, unknown>;\n        },\n      ): Promise<WorkflowEvent> => {\n        const res = await fetch(`${base}/events`, {\n          method: \"POST\",\n\n          headers: self.headers,\n\n          body: JSON.stringify({ runId, ...data }),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      /**\n       * Lists events for a workflow run.\n       */\n      listEvents: async (runId: string): Promise<WorkflowEvent[]> => {\n        const res = await fetch(`${base}/runs/${runId}/events`, {\n          headers: self.headers,\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      /**\n       * Polls a queue for a message.\n       */\n      pollQueue: async (queueName: string): Promise<unknown> => {\n        const res = await fetch(`${base}/queue/${queueName}`, {\n          headers: self.headers,\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        const text = await res.text();\n\n        return text ? JSON.parse(text) : null;\n      },\n\n      /**\n       * Sends a signal to a running workflow.\n       * @param runId - The run ID.\n       * @param signalName - The signal name.\n       * @param data - The signal payload.\n       * @param correlationId - Optional correlation ID.\n       */\n      sendSignal: async (\n        runId: string,\n        signalName: string,\n        data: any,\n        correlationId?: string,\n      ): Promise<boolean> => {\n        // 1. Create signal event\n\n        await self.workflow.createEvent(runId, {\n          eventType: \"signal_received\",\n\n          correlationId: correlationId ||\n            `signal-${signalName}-${crypto.randomUUID()}`, // Deterministic ID for the signal\n\n          payload: { name: signalName, data },\n        });\n\n        // 2. Queue workflow for execution\n\n        const run = await self.workflow.getRun(runId);\n\n        await self.workflow.queueMessage(`__wkf_workflow_${run.workflowName}`, {\n          type: \"signal\",\n\n          runId: runId,\n\n          workflowName: run.workflowName,\n\n          input: run.input,\n        });\n\n        return true;\n      },\n\n      /**\n       * Enqueues a message.\n       */\n      queueMessage: async (\n        queueName: string,\n        message: any,\n        opts?: any,\n      ): Promise<unknown> => {\n        const res = await fetch(`${base}/queue`, {\n          method: \"POST\",\n\n          headers: self.headers,\n\n          body: JSON.stringify({ queueName, message, opts }),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      /**\n       * Acknowledges a message (removes it from queue).\n       */\n      ack: async (messageId: string): Promise<unknown> => {\n        const res = await fetch(`${base}/queue/ack`, {\n          method: \"POST\",\n\n          headers: self.headers,\n\n          body: JSON.stringify({ messageId }),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      /**\n       * Negative acknowledges a message (returns it to queue).\n       */\n      nack: async (messageId: string): Promise<unknown> => {\n        const res = await fetch(`${base}/queue/nack`, {\n          method: \"POST\",\n\n          headers: self.headers,\n\n          body: JSON.stringify({ messageId }),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      /**\n       * Touches a message (extends visibility timeout).\n       */\n      touch: async (messageId: string): Promise<unknown> => {\n        const res = await fetch(`${base}/queue/touch`, {\n          method: \"POST\",\n\n          headers: self.headers,\n\n          body: JSON.stringify({ messageId }),\n        });\n\n        if (!res.ok) throw new Error(await res.text());\n\n        return res.json();\n      },\n\n      /**\n       * Namespace for workflow hooks.\n       */\n      hooks: {\n        /**\n         * Creates a new hook for a workflow run.\n         */\n        create: async (runId: string, data: any): Promise<unknown> => {\n          const res = await fetch(`${base}/hooks`, {\n            method: \"POST\",\n\n            headers: self.headers,\n\n            body: JSON.stringify({ runId, ...data }),\n          });\n\n          if (!res.ok) throw new Error(await res.text());\n\n          return res.json();\n        },\n\n        /**\n         * Gets a hook by ID.\n         */\n        get: async (id: string): Promise<unknown> => {\n          const res = await fetch(`${base}/hooks/${id}`, {\n            headers: self.headers,\n          });\n\n          if (!res.ok) throw new Error(await res.text());\n\n          return res.json();\n        },\n\n        /**\n         * Gets a hook by token.\n         */\n        getByToken: async (token: string): Promise<unknown> => {\n          const res = await fetch(`${base}/hooks?token=${token}`, {\n            headers: self.headers,\n          });\n\n          if (!res.ok) throw new Error(await res.text());\n\n          return res.json();\n        },\n\n        /**\n         * Lists hooks for a workflow run.\n         */\n        list: async (runId: string): Promise<unknown> => {\n          const res = await fetch(`${base}/hooks?runId=${runId}`, {\n            headers: self.headers,\n          });\n\n          if (!res.ok) throw new Error(await res.text());\n\n          return res.json();\n        },\n\n        /**\n         * Disposes/Deletes a hook.\n         */\n        dispose: async (id: string): Promise<unknown> => {\n          const res = await fetch(`${base}/hooks/${id}`, {\n            method: \"DELETE\",\n\n            headers: self.headers,\n          });\n\n          if (!res.ok) throw new Error(await res.text());\n\n          return res.json();\n        },\n      },\n    };\n  }\n\n  /**\n   * Calls a Gate (custom API endpoint) defined in the backend.\n   * @param name - The name of the gate to call.\n   * @param data - The data payload to send (optional).\n   * @param options - Additional fetch options (optional).\n   * @returns A promise that resolves to the fetch Response.\n   */\n  async gate(\n    name: string,\n    data?: any,\n    options?: RequestInit,\n  ): Promise<Response> {\n    const fetchOptions: RequestInit = {\n      method: \"POST\",\n\n      ...options,\n\n      headers: {\n        ...this.headers,\n\n        ...(options?.headers || {}),\n      },\n    };\n\n    if (data) {\n      fetchOptions.body = JSON.stringify(data);\n    }\n\n    return await fetch(`${this.baseUrl}/api/gates/${name}`, fetchOptions);\n  }\n}\n", "/**\n * Internal error used to signal that a workflow execution is suspended.\n * This is caught by the worker to save state and exit the execution loop.\n */\nexport class WorkflowSuspension extends Error {\n  /**\n   * Creates a new WorkflowSuspension error.\n   * @param message - The reason for suspension.\n   */\n  constructor(message: string = \"Workflow suspended\") {\n    super(message);\n    this.name = \"WorkflowSuspension\";\n  }\n}\n", "// Copyright (c) 2025 Anton A Nesterov <an+vski@vski.sh>, VSKI License\n//\n\nimport type { RocketBaseClient } from \"./client.ts\";\nimport { WorkflowSuspension } from \"./suspension.ts\";\nimport type { StepOptions, WorkflowEvent, WorkflowOptions } from \"./types.ts\";\n\n/**\n * Base class for all workflow implementations.\n * Provides the core logic for step execution, state management, idempotency, and signal handling.\n * Workflows extending this class (or using the functional wrapper) inherit these capabilities.\n */\nexport class WorkflowBase {\n  /** The RocketBase client instance used for API calls. */\n  public client!: RocketBaseClient;\n  /** Unique identifier for the current workflow run. */\n  public runId: string = \"\";\n  /** Name of the workflow. */\n  public workflowName: string = \"unknown\";\n  /** Options used for the workflow execution. */\n  public workflowOptions: WorkflowOptions = {};\n\n  /** History of step results, indexed by step correlation ID. */\n  public history = new Map<string, unknown>();\n  /** Set of successfully completed step IDs. */\n  public completedSteps = new Set<string>();\n  /** Stack of rollback method names to call if the workflow fails. */\n  public rollbackStack: string[] = [];\n  /** Map tracking the number of attempts for each step ID. */\n  public stepAttempts = new Map<string, number>();\n\n  /** Counter for generating sequential IDs for steps and sleeps. */\n  public callCounter: number = 0;\n  /** Buffered signal data, indexed by signal name. */\n  public signalQueues = new Map<string, any[]>();\n  /** Cursors for signal queues to handle multiple waits for the same signal. */\n  public signalCursors = new Map<string, number>();\n  /** Flag indicating if the workflow is currently suspended. */\n  public isSuspended: boolean = false;\n  /** Set of step IDs that have been invoked during the current execution. */\n  public invokedSteps = new Set<string>();\n  /** Set of event IDs that have been emitted to the backend. */\n  public emittedEvents = new Set<string>();\n\n  /**\n   * Creates a new instance of WorkflowBase.\n   * @param client - Optional RocketBase client instance.\n   */\n  constructor(client?: RocketBaseClient) {\n    if (client) this.client = client;\n  }\n\n  /**\n   * Executes multiple steps in parallel.\n   * @param steps - An array of functions returning promises to be executed concurrently.\n   * @returns An array of results from the executed steps.\n   */\n  async parallel<T>(steps: (() => Promise<T>)[]): Promise<T[]> {\n    return await Promise.all(steps.map((s) => s()));\n  }\n\n  /**\n   * Generates a sequential ID for steps or sleeps that don't have a manual ID.\n   * NOTE: This is order-dependent. Adding or removing steps will shift these IDs\n   * and can break long-running workflows during replay.\n   * @param prefix - The prefix for the ID (e.g., \"step\", \"sleep\").\n   * @returns A generated unique ID.\n   */\n  public getSequentialId(prefix: string): string {\n    const id = `${prefix}-${this.callCounter++}`;\n    return id;\n  }\n\n  /**\n   * Pauses execution for a specified duration.\n   * This method supports idempotency and replay.\n   * @param duration - The duration to sleep in milliseconds or as a string (e.g., \"1s\", \"5m\").\n   * @returns A promise that resolves when the sleep is completed.\n   * @throws {WorkflowSuspension} When the sleep starts, suspending execution until the duration passes.\n   */\n  async sleep(duration: number | string): Promise<void> {\n    const id = this.getSequentialId(\"sleep\");\n    if (this.completedSteps.has(id)) {\n      console.log(\n        `[Workflow ${this.workflowName}] Sleep ${id} already completed, skipping`,\n      );\n      return;\n    }\n\n    if (!this.runId) {\n      throw new Error(\"Cannot sleep outside of a workflow context.\");\n    }\n\n    if (this.emittedEvents.has(id)) {\n      console.log(\n        `[Workflow ${this.workflowName}] Sleep ${id} already emitted, suspending`,\n      );\n      this.isSuspended = true;\n      throw new WorkflowSuspension(`Sleeping for ${id}`);\n    }\n\n    let ms = 0;\n    if (typeof duration === \"string\") {\n      if (duration.endsWith(\"s\")) {\n        ms = parseFloat(duration) * 1000;\n      } else if (duration.endsWith(\"m\")) {\n        ms = parseFloat(duration) * 60000;\n      } else if (duration.endsWith(\"ms\")) {\n        ms = parseFloat(duration);\n      } else {\n        // Default to ms if no suffix, or try parsing\n        ms = parseFloat(duration);\n        if (isNaN(ms)) throw new Error(`Invalid duration format: ${duration}`);\n      }\n    } else {\n      ms = duration;\n    }\n\n    const resumeAt = new Date(Date.now() + ms);\n\n    await this.client.workflow.createEvent(this.runId, {\n      eventType: \"wait_created\",\n      correlationId: id,\n      payload: { duration: ms, resumeAt: resumeAt.toISOString() },\n    });\n    this.emittedEvents.add(id);\n\n    this.isSuspended = true;\n    throw new WorkflowSuspension(`Sleeping for ${ms}ms`);\n  }\n\n  /**\n   * Pauses execution until a specific signal is received.\n   * This method supports idempotency and replay.\n   * @param name - The name of the signal to wait for.\n   * @returns The data payload associated with the signal.\n   * @throws {WorkflowSuspension} When waiting for the signal, suspending execution until it arrives.\n   */\n  async waitForSignal<T = unknown>(name: string): Promise<T> {\n    const id = this.getSequentialId(`signal-${name}`);\n    if (this.history.has(id)) {\n      const data = this.history.get(id) as T;\n      console.log(\n        `[Workflow ${this.workflowName}] Signal ${id} replayed from history`,\n      );\n      // Sync cursor if this strictly matched signal is also in the queue at current position\n      const queue = this.signalQueues.get(name);\n      if (queue) {\n        const cursor = this.signalCursors.get(name) || 0;\n        if (cursor < queue.length && queue[cursor] === data) {\n          this.signalCursors.set(name, cursor + 1);\n        }\n      }\n      return data;\n    }\n\n    const queue = this.signalQueues.get(name);\n    if (queue) {\n      const cursor = this.signalCursors.get(name) || 0;\n      if (cursor < queue.length) {\n        const data = queue[cursor];\n        console.log(\n          `[Workflow ${this.workflowName}] Signal ${id} pulled from signal queue at cursor ${cursor}`,\n        );\n        this.signalCursors.set(name, cursor + 1);\n        return data as T;\n      }\n    }\n\n    if (!this.runId) {\n      throw new Error(\"Cannot wait for signal outside of a workflow context.\");\n    }\n\n    if (this.emittedEvents.has(id)) {\n      console.log(\n        `[Workflow ${this.workflowName}] Signal ${id} already waiting, suspending`,\n      );\n      this.isSuspended = true;\n      throw new WorkflowSuspension(`Waiting for signal: ${name}`);\n    }\n\n    await this.client.workflow.createEvent(this.runId, {\n      eventType: \"signal_waiting\",\n      correlationId: id,\n      payload: { name },\n    });\n    this.emittedEvents.add(id);\n\n    this.isSuspended = true;\n    throw new WorkflowSuspension(`Waiting for signal: ${name}`);\n  }\n\n  /**\n   * Executes the rollback stack in reverse order.\n   * This is called when a workflow fails and needs to compensate for completed steps.\n   * @param error - The error that triggered the rollback.\n   * @returns A promise that resolves when the rollback is complete.\n   */\n  async runRollback(error: unknown): Promise<void> {\n    const accumulator: Record<string, unknown> = {};\n    const stack = [...this.rollbackStack];\n    while (stack.length > 0) {\n      const method = stack.pop()!;\n      if (typeof (this as Record<string, unknown>)[method] === \"function\") {\n        try {\n          const result = await (this as unknown as Record<string, Function>)\n            [method](error, accumulator);\n          accumulator[method] = result;\n        } catch (e) {\n          if (e.name === \"StopRollback\") break;\n          console.error(`Rollback method ${method} failed:`, e.message);\n        }\n      }\n    }\n  }\n\n  /**\n   * Reconstructs the workflow state from a list of events.\n   * Used when resuming a workflow or replaying history.\n   * @param events - The list of events from the workflow run.\n   */\n  rebuildState(events: WorkflowEvent[]): void {\n    this.history.clear();\n    this.completedSteps.clear();\n    this.invokedSteps.clear();\n    this.emittedEvents.clear();\n    this.rollbackStack = [];\n    this.stepAttempts.clear();\n    this.signalQueues.clear();\n    this.signalCursors.clear();\n    this.callCounter = 0;\n    this.isSuspended = false;\n\n    for (const event of events) {\n      const payload = event.payload || {};\n      if (event.correlationId) {\n        this.emittedEvents.add(event.correlationId);\n      }\n      switch (event.eventType) {\n        case \"step_completed\":\n          this.completedSteps.add(event.correlationId!);\n          this.history.set(event.correlationId!, payload.output);\n          break;\n        case \"wait_completed\":\n          this.completedSteps.add(event.correlationId!);\n          break;\n        case \"signal_received\":\n          this.history.set(event.correlationId!, payload.data);\n          if (payload.name) {\n            const name = payload.name as string;\n            if (!this.signalQueues.has(name)) {\n              this.signalQueues.set(name, []);\n            }\n            this.signalQueues.get(name)!.push(payload.data);\n          }\n          break;\n        case \"rollback_registered\":\n          this.rollbackStack.push(payload.method as string);\n          break;\n        case \"step_retrying\":\n          this.stepAttempts.set(\n            event.correlationId!,\n            payload.attempt as number,\n          );\n          break;\n      }\n    }\n  }\n\n  /**\n   * Executes a single step within the workflow with idempotency, retries, and rollback support.\n   * @param id - The unique identifier for the step.\n   * @param fn - The function implementing the step logic.\n   * @param args - Arguments to pass to the function.\n   * @param options - Options for retries, rollback, and timeout.\n   * @returns The result of the step execution.\n   */\n  async executeStep<T>(\n    id: string,\n    fn: (...args: any[]) => Promise<T>,\n    args: any[],\n    options: StepOptions = {},\n  ): Promise<T> {\n    if (!this.runId) return fn.apply(this, args);\n\n    if (this.invokedSteps.has(id)) {\n      throw new Error(\n        `Duplicate step ID detected: \"${id}\". Each step within a workflow must have a unique ID.`,\n      );\n    }\n    this.invokedSteps.add(id);\n\n    if (this.completedSteps.has(id)) {\n      console.log(\n        `[Workflow ${this.workflowName}] Step ${id} already completed, replaying from history`,\n      );\n      return this.history.get(id) as T;\n    }\n\n    if (options.rollback) {\n      for (const method of options.rollback) {\n        const cid = `${id}-rb-${method}`;\n        if (!this.history.has(cid)) {\n          await this.client.workflow.createEvent(this.runId, {\n            eventType: \"rollback_registered\",\n            correlationId: cid,\n            payload: { method },\n          });\n          this.rollbackStack.push(method);\n        }\n      }\n    }\n\n    const maxRetries = options.retries || 0;\n    let attempt = 0;\n\n    // Initialize attempts if not present (from history reconstruction)\n    if (!this.stepAttempts.has(id)) {\n      this.stepAttempts.set(id, 0);\n    }\n    attempt = this.stepAttempts.get(id)!;\n\n    while (true) {\n      try {\n        if (!this.emittedEvents.has(id)) {\n          console.log(\n            `[Workflow ${this.workflowName}] Step ${id} starting (Attempt ${attempt})`,\n          );\n          await this.client.workflow.createEvent(this.runId, {\n            eventType: \"step_started\",\n            correlationId: id,\n            payload: { attempt },\n          });\n          this.emittedEvents.add(id);\n        }\n        const result = await fn.apply(this, args);\n        console.log(`[Workflow ${this.workflowName}] Step ${id} completed`);\n        await this.client.workflow.createEvent(this.runId, {\n          eventType: \"step_completed\",\n          correlationId: id,\n          payload: { output: result },\n        });\n        this.completedSteps.add(id);\n        this.history.set(id, result);\n        return result;\n      } catch (e) {\n        if (attempt < maxRetries) {\n          attempt++;\n          this.stepAttempts.set(id, attempt);\n          await this.client.workflow.createEvent(this.runId, {\n            eventType: \"step_retrying\",\n            correlationId: id,\n            payload: { error: e.message, attempt },\n          });\n          await new Promise((r) => setTimeout(r, 1000 * attempt));\n          continue;\n        }\n        await this.client.workflow.createEvent(this.runId, {\n          eventType: \"step_failed\",\n          correlationId: id,\n          payload: { error: e.message, attempt },\n        });\n        throw e;\n      }\n    }\n  }\n}\n", "// Copyright (c) 2025 Anton A Nesterov <an+vski@vski.sh>, VSKI License\n//\n\nimport { WorkflowRegistry } from \"./registry.ts\";\nimport type { StepOptions, WorkflowOptions } from \"./types.ts\";\nimport type { WorkflowBase } from \"./workflow-base.ts\";\nimport { WorkflowSuspension } from \"./suspension.ts\";\n\n/**\n * Decorator to define a class as a Workflow.\n * Wraps the class to handle initialization, execution, and state management via RocketBase.\n * @param name - The unique name of the workflow.\n * @param options - Configuration options for the workflow (e.g., max events, timeout).\n * @returns A class decorator function.\n */\nexport function Workflow(\n  name: string,\n  options: WorkflowOptions = {},\n): (constructor: Function) => void {\n  return function (constructor: Function): void {\n    WorkflowRegistry.set(name, constructor);\n    constructor.prototype.workflowName = name;\n    constructor.prototype.workflowOptions = options;\n\n    const originalRun = constructor.prototype.run;\n    if (originalRun) {\n      constructor.prototype.run = async function (...args: any[]) {\n        const self = this as WorkflowBase;\n        if (!self.client) throw new Error(\"Workflow needs a RocketBaseClient.\");\n\n        if (!self.runId) {\n          const run = await self.client.workflow.trigger(name, args, options);\n          self.runId = run.runId;\n        }\n\n        // Update status to running\n        await self.client.workflow.updateRun(self.runId, { status: \"running\" });\n\n        try {\n          const result = await originalRun.apply(self, args);\n          if (!self.isSuspended) {\n            await self.client.workflow.updateRun(self.runId, {\n              status: \"completed\",\n              output: result,\n            });\n          }\n          return result;\n        } catch (e: any) {\n          if (e instanceof WorkflowSuspension) {\n            // Workflow is suspended, just exit.\n            // Note: isSuspended is already true.\n            return;\n          }\n          console.error(`[Workflow ${name}] Failed:`, e.message);\n          try {\n            await self.runRollback(e);\n          } catch (re: any) {\n            console.error(`[Workflow ${name}] Rollback failed:`, re.message);\n          }\n          await self.client.workflow.updateRun(self.runId!, {\n            status: \"failed\",\n            error: { message: e.message, stack: e.stack },\n          });\n          throw e;\n        }\n      };\n    }\n  };\n}\n\n/**\n * Decorator to define a method as a Step within a Workflow.\n * Wraps the method to provide idempotency, retries, and rollback capabilities.\n * @param id - The unique identifier for the step.\n * @param options - Options for retries, rollback methods, and timeout.\n * @returns A method decorator function.\n */\nexport function Step(\n  id: string,\n  options: StepOptions = {},\n): (\n  _target: any,\n  _propertyKey: string,\n  descriptor: PropertyDescriptor,\n) => void {\n  return function (\n    _target: any,\n    _propertyKey: string,\n    descriptor: PropertyDescriptor,\n  ): void {\n    const originalMethod = descriptor.value;\n    descriptor.value = async function (...args: any[]) {\n      const self = this as WorkflowBase;\n      return self.executeStep(id, originalMethod, args, options);\n    };\n  };\n}\n", "// Copyright (c) 2025 Anton A Nesterov <an+vski@vski.sh>, VSKI License\n//\n\nimport type { RocketBaseClient } from \"./client.ts\";\nimport { WorkflowRegistry } from \"./registry.ts\";\nimport { WorkflowSuspension } from \"./suspension.ts\";\nimport type { WorkflowJob, WorkflowRun } from \"./types.ts\";\n\n/**\n * Worker class responsible for polling and executing workflow jobs.\n * Connects to the RocketBase backend via WebSocket to receive job assignments.\n */\nexport class WorkflowWorker {\n  private active = false;\n  private workflowNames = new Set<string>();\n  private stopCallback: (() => void) | null = null;\n  private activeJobs = new Set<Promise<void>>();\n  private unsubscribers = new Map<string, () => void>();\n\n  /**\n   * Creates a new instance of WorkflowWorker.\n   * @param client - The RocketBase client instance.\n   */\n  constructor(private client: RocketBaseClient) {}\n\n  /**\n   * Starts the worker for one or more workflows.\n   * @param workflowName - The name of the workflow(s) to process.\n   * @param options - Options for concurrency and resuming pending runs.\n   * @returns A promise that resolves when the worker is stopped.\n   */\n  start(\n    workflowName: string | string[],\n    options: { concurrency?: number; resume?: boolean } = {},\n  ): Promise<void> {\n    this.active = true;\n    const names = Array.isArray(workflowName) ? workflowName : [workflowName];\n\n    for (const name of names) {\n      this.workflowNames.add(name);\n      const unsub = this.client.subscribeWorkflow(name, (job) => {\n        if (!this.active) return;\n        const promise = this.processJob(job);\n        this.activeJobs.add(promise);\n        promise.finally(() => this.activeJobs.delete(promise));\n      });\n      this.unsubscribers.set(name, unsub);\n\n      if (options.resume) {\n        this.resumePending(name).catch((e) =>\n          console.error(`[Worker ${name}] Resume failed:`, e)\n        );\n      }\n    }\n\n    return new Promise((resolve) => {\n      this.stopCallback = resolve;\n    });\n  }\n\n  /**\n   * Resumes pending and running runs for the workflow.\n   * @param workflowName - The name of the workflow.\n   */\n  private async resumePending(workflowName: string): Promise<void> {\n    // Fetch runs that are not completed/failed\n    const pending = await this.client.workflow.listRuns({\n      workflowName,\n      status: \"pending\",\n    });\n    const running = await this.client.workflow.listRuns({\n      workflowName,\n      status: \"running\",\n    });\n\n    const all: WorkflowRun[] = [\n      ...(pending.items ||\n        (pending as unknown as { data: WorkflowRun[] }).data || []),\n      ...(running.items ||\n        (running as unknown as { data: WorkflowRun[] }).data || []),\n    ];\n    console.log(`[Worker ${workflowName}] Resuming ${all.length} runs`);\n\n    for (const run of all) {\n      await this.client.workflow.resume(run.runId);\n    }\n  }\n\n  /**\n   * Stops the worker, closing the connection and waiting for active jobs to complete.\n   * @returns A promise that resolves when the worker is fully stopped.\n   */\n  async stop(): Promise<void> {\n    this.active = false;\n    for (const unsub of this.unsubscribers.values()) {\n      unsub();\n    }\n    this.unsubscribers.clear();\n\n    if (this.activeJobs.size > 0) {\n      console.log(\n        `[Worker] Waiting for ${this.activeJobs.size} jobs to complete...`,\n      );\n      await Promise.allSettled(this.activeJobs);\n    }\n\n    if (this.stopCallback) {\n      this.stopCallback();\n      this.stopCallback = null;\n    }\n  }\n\n  /**\n   * Processes a single job assignment.\n   * Reconstructs the workflow state and attempts to execute it.\n   * @param job - The job data received from the server.\n   * @returns A promise that resolves when the job processing is complete.\n   */\n  async processJob(job: WorkflowJob): Promise<void> {\n    const workflowName = job.data.workflowName || \"unknown\";\n    console.log(`[Worker ${workflowName}] Processing job ${job.id}`);\n    const { runId, input } = job.data;\n\n    // Start heartbeat\n    const heartbeatInterval = setInterval(async () => {\n      try {\n        await this.client.workflow.touch(job.id);\n      } catch (_e) {\n        console.warn(\n          `[Worker ${workflowName}] Heartbeat failed for job ${job.id}`,\n        );\n      }\n    }, 15000); // Every 15 seconds (well within the 30s timeout)\n\n    // The job.data should contain the inputs\n    // Check for correct workflow\n    if (\n      job.data.workflowName && !this.workflowNames.has(job.data.workflowName)\n    ) {\n      console.warn(\n        `[Worker] Received job for ${job.data.workflowName}, but not registered to handle it. Ignoring.`,\n      );\n      clearInterval(heartbeatInterval);\n      await this.client.workflow.nack(job.id);\n      return;\n    }\n\n    try {\n      const [run, events] = await Promise.all([\n        this.client.workflow.getRun(runId),\n        this.client.workflow.listEvents(runId),\n      ]);\n\n      const Class = WorkflowRegistry.get(workflowName);\n      if (!Class) {\n        console.error(\n          `[Worker ${workflowName}] Workflow class not found in registry. Registered:`,\n          Array.from(WorkflowRegistry.keys()),\n        );\n        clearInterval(heartbeatInterval);\n        await this.client.workflow.nack(job.id);\n        return;\n      }\n\n      const instance = new Class(this.client);\n      instance.runId = runId;\n      instance.rebuildState(events);\n\n      // Execute with timeout\n      const timeout = run.executionTimeout || 30000;\n      let timeoutId: NodeJS.Timeout | number | undefined;\n      const timeoutPromise = new Promise((_, reject) => {\n        timeoutId = setTimeout(\n          () => reject(new Error(\"CircuitBreaker: Execution timeout\")),\n          timeout,\n        );\n      });\n\n      try {\n        await Promise.race([\n          instance.run(...(input || [])),\n          timeoutPromise,\n        ]);\n      } finally {\n        if (timeoutId) clearTimeout(timeoutId as number);\n      }\n\n      // If we get here, execution completed successfully (or suspended successfully)\n      // Ack the job\n      clearInterval(heartbeatInterval);\n      await this.client.workflow.ack(job.id);\n      if (instance.isSuspended) {\n        console.log(`[Worker ${workflowName}] Job ${job.id} suspended`);\n      } else {\n        console.log(`[Worker ${workflowName}] Job ${job.id} completed`);\n      }\n    } catch (e: unknown) {\n      clearInterval(heartbeatInterval);\n\n      if (e instanceof WorkflowSuspension) {\n        await this.client.workflow.ack(job.id);\n        console.log(`[Worker ${workflowName}] Job ${job.id} suspended`);\n        return;\n      }\n\n      const message = e instanceof Error ? e.message : String(e);\n      console.error(\n        `[Worker ${workflowName}] Job ${job.id} failed:`,\n        message,\n      );\n\n      if (message === \"CircuitBreaker: Execution timeout\") {\n        try {\n          await this.client.workflow.updateRun(runId, {\n            status: \"failed\",\n            error: { message: message },\n          });\n        } catch (err) {\n          console.error(\n            `[Worker ${workflowName}] Failed to update run status:`,\n            err,\n          );\n        }\n      }\n\n      await this.client.workflow.ack(job.id);\n    }\n  }\n}\n", "// Copyright (c) 2025 Anton A Nesterov <an+vski@vski.sh>, VSKI License\n//\n\n/**\n * Error thrown to stop the rollback process in a workflow.\n * When thrown inside a rollback handler, it prevents further rollback steps from executing.\n */\nexport class StopRollback extends Error {\n  /**\n   * Creates a new StopRollback error.\n   * @param message - The error message.\n   */\n  constructor(message: string = \"Rollback stopped\") {\n    super(message);\n    this.name = \"StopRollback\";\n  }\n}\n", "// Copyright (c) 2025 Anton A Nesterov <an+vski@vski.sh>, VSKI License\n//\n\n/**\n * Manages the execution context for functional workflows.\n * Used to store and retrieve the current workflow instance across async calls.\n */\n\n// Try to use AsyncLocalStorage for concurrency safety in Deno/Node\n// Fallback to global variable for browser\nlet storage: {\n  run: <T>(ctx: unknown, fn: () => T) => T;\n  getStore: () => unknown;\n};\n\n// Check for AsyncLocalStorage (Node/Deno)\n// ts-ignore: unstable apis\nconst AsyncLocalStorage = globalThis.AsyncLocalStorage ||\n  // ts-ignore: unstable apis\n  ((await import(\"node:async_hooks\").catch(() => ({}))) as Record<\n    string,\n    unknown\n  >).AsyncLocalStorage;\n\nif (AsyncLocalStorage) {\n  const als = new AsyncLocalStorage();\n  storage = {\n    run: (ctx, fn) => als.run(ctx, fn),\n    getStore: () => als.getStore(),\n  };\n} else {\n  // Browser fallback - NOT concurrency safe for interleaved async calls\n  let currentContext: unknown = null;\n  storage = {\n    run: <T>(ctx, fn) => {\n      const prev = currentContext;\n      currentContext = ctx;\n      try {\n        const result = fn();\n        if (result instanceof Promise) {\n          return (result as Promise<T>).finally(() => {\n            currentContext = prev;\n          });\n        }\n        currentContext = prev;\n        return result;\n      } catch (e) {\n        currentContext = prev;\n        throw e;\n      }\n    },\n    getStore: () => currentContext,\n  };\n  if (typeof window !== \"undefined\") {\n    console.warn(\n      \"[RocketBase] Using global context storage. Interleaved functional workflow execution might be non-deterministic in browser.\",\n    );\n  }\n}\n\nexport const WorkflowContext = storage;\n", "// Copyright (c) 2025 Anton A Nesterov <an+vski@vski.sh>, VSKI License\n//\n\nimport { WorkflowRegistry } from \"./registry.ts\";\nimport { WorkflowBase } from \"./workflow-base.ts\";\nimport { WorkflowContext as ContextManager } from \"./context.ts\";\nimport { WorkflowSuspension } from \"./suspension.ts\";\nimport type { StepOptions, WorkflowContext, WorkflowOptions } from \"./types.ts\";\n\n/**\n * Defines a functional workflow.\n * @param name - The unique name of the workflow.\n * @param options - Configuration options for the workflow.\n * @returns An object with a `run` method to define the workflow logic.\n */\nexport function workflow(\n  name: string,\n  options: WorkflowOptions = {},\n): {\n  run: (\n    fn: (ctx: WorkflowContext, ...args: any[]) => Promise<any>,\n  ) => typeof WorkflowBase;\n} {\n  return {\n    /**\n     * Defines the execution logic of the workflow.\n     * @param fn - A function that takes a context object and arguments, returning a Promise.\n     * @returns A class constructor that implements the workflow.\n     */\n    run: (\n      fn: (ctx: WorkflowContext, ...args: any[]) => Promise<any>,\n    ): typeof WorkflowBase => {\n      // Create a dynamic class that extends WorkflowBase\n      const FunctionalWorkflow = class extends WorkflowBase {\n        static workflowName = name;\n        override workflowName = name;\n        override workflowOptions = options;\n\n        async run(...args: any[]) {\n          const self = this;\n          return await ContextManager.run(this, async () => {\n            try {\n              return await (fn as any).call(self, self, ...args);\n            } catch (e: any) {\n              throw e;\n            }\n          });\n        }\n      };\n\n      // Register context-aware wrapper similar to @Workflow decorator\n      WorkflowRegistry.set(name, FunctionalWorkflow);\n\n      // Monkey-patch prototype run to add the standard lifecycle logic\n      // (trigger check, status updates, rollback)\n      // This duplicates logic from @Workflow decorator. Ideally we extract it.\n      // But for now, let's implement it here.\n\n      const originalRun = FunctionalWorkflow.prototype.run;\n      FunctionalWorkflow.prototype.run = async function (...args: any[]) {\n        const self = this as WorkflowBase;\n        if (!self.client) throw new Error(\"Workflow needs a RocketBaseClient.\");\n\n        if (!self.runId) {\n          const run = await self.client.workflow.trigger(name, args, options);\n          self.runId = run.runId;\n        }\n\n        // Update status to running\n        await self.client.workflow.updateRun(self.runId, { status: \"running\" });\n\n        try {\n          const result = await (originalRun as any).apply(self, args);\n          if (!self.isSuspended) {\n            await self.client.workflow.updateRun(self.runId, {\n              status: \"completed\",\n              output: result,\n            });\n          }\n          return result;\n        } catch (e: any) {\n          if (e instanceof WorkflowSuspension) {\n            return;\n          }\n          console.error(`[Workflow ${name}] Failed:`, e.message);\n          try {\n            await self.runRollback(e);\n          } catch (re: any) {\n            console.error(`[Workflow ${name}] Rollback failed:`, re.message);\n          }\n          await self.client.workflow.updateRun(self.runId!, {\n            status: \"failed\",\n            error: { message: e.message, stack: e.stack },\n          });\n          throw e;\n        }\n      };\n\n      return FunctionalWorkflow;\n    },\n  };\n}\n\n/**\n * Defines a step within a functional workflow.\n * Can be used to wrap a function or define a block of code as a step.\n * @param idOrFn - The step ID (string) or the function to wrap.\n * @param fnOrOptions - The function (if ID was first) or options (if function was first).\n * @param options - Options for retries, rollback, etc. (if ID was first).\n * @returns A wrapped function that executes as a workflow step.\n */\nexport function step<T extends (...args: any[]) => Promise<any>>(\n  idOrFn: string | T,\n  fnOrOptions?: T | StepOptions,\n  options?: StepOptions,\n): T {\n  let id: string;\n  let fn: T;\n  let opts: StepOptions = {};\n\n  if (typeof idOrFn === \"string\") {\n    id = idOrFn;\n    fn = fnOrOptions as T;\n    opts = options || {};\n  } else {\n    fn = idOrFn;\n    id = \"\"; // Will be generated at runtime\n    opts = (fnOrOptions as StepOptions) || {};\n  }\n\n  return (async function (this: WorkflowContext | void, ...args: any[]) {\n    const context = (this instanceof WorkflowBase)\n      ? this as unknown as WorkflowBase\n      : ContextManager.getStore() as WorkflowBase;\n\n    if (!context) {\n      // If called outside of workflow context, just run the function\n      return await fn(...args);\n    }\n\n    // Generate ID if missing using the context's deterministic counter\n    // Use function name as prefix if available to make it less brittle than just \"step\"\n    const prefix = fn.name || \"step\";\n    const effectiveId = id || context.getSequentialId(prefix);\n\n    // We bind the function to the context so 'this' works inside the step implementation\n    return context.executeStep(effectiveId, fn.bind(context), args, opts);\n  } as unknown) as T;\n}\n"],
  "mappings": "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",
  "names": ["WorkflowRegistry", "RocketBaseClient", "baseUrl", "token", "key", "db", "workflowName", "callback", "subs", "wsUrl", "_", "name", "event", "msg", "arr", "listener", "e", "h", "self", "res", "data", "id", "email", "pass", "provider", "code", "redirectUrl", "identity", "password", "resData", "filters", "params", "value", "page", "perPage", "options", "q", "slug", "isFormData", "ids", "sub", "err", "migrations", "applied", "appliedNames", "m", "mig", "base", "input", "mergedOptions", "WorkflowRegistry", "run", "runId", "p", "stepId", "queueName", "text", "signalName", "correlationId", "message", "opts", "messageId", "fetchOptions", "WorkflowSuspension", "message", "WorkflowBase", "client", "steps", "prefix", "duration", "id", "WorkflowSuspension", "ms", "resumeAt", "name", "data", "queue", "cursor", "error", "accumulator", "stack", "method", "result", "e", "events", "event", "payload", "fn", "args", "options", "cid", "maxRetries", "attempt", "r", "Workflow", "name", "options", "constructor", "WorkflowRegistry", "originalRun", "args", "self", "run", "result", "e", "WorkflowSuspension", "re", "Step", "id", "_target", "_propertyKey", "descriptor", "originalMethod", "WorkflowWorker", "client", "workflowName", "options", "names", "name", "unsub", "job", "promise", "e", "resolve", "pending", "running", "all", "run", "runId", "input", "heartbeatInterval", "events", "Class", "WorkflowRegistry", "instance", "timeout", "timeoutId", "timeoutPromise", "_", "reject", "WorkflowSuspension", "message", "err", "StopRollback", "message", "storage", "AsyncLocalStorage", "als", "ctx", "fn", "currentContext", "prev", "result", "e", "WorkflowContext", "workflow", "name", "options", "fn", "FunctionalWorkflow", "WorkflowBase", "args", "self", "WorkflowContext", "e", "WorkflowRegistry", "originalRun", "run", "result", "WorkflowSuspension", "re", "step", "idOrFn", "fnOrOptions", "id", "opts", "context", "prefix", "effectiveId"]
}
